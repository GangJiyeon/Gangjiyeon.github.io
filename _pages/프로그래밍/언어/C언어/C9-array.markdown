---
title: "[C언어] 배열(array)"
tags:
    - C언어기초
date: "2024-12-09"
thumbnail: "/assets/img/thumbnail/book.jpg"
---
이번에는 C언어의 배열(array)에 대해 알아보자.    


## **배열**
### **배열이란**
**1) 배열(array)이란**
* `자료구조`(자료를 효율적으로 저장하기 위한 구조)의 일종
* 한 자료유형의 변수들이 동일한 크기의 연속된 메모리에 저장되는 구조

**2) 배열의 요소** 👉 배열원소의 자료형, 배열이름, 배열크기
* 배열원소(elements) : 배열을 구성하는 각각의 항복, index(첨자)를 이용해 쉽게 접근 가능

<br>

### **배열선언과 초기화**
**1) 배열선언과 초기화**

* 배열선언 후 값 초기화하기

```c
원소자료형 배열이름[배열크기];
배열이름[배열크기] = 원소값;
```

```c
int array[3];			//초기값을 저장하지 않으면 쓰레기값이 저장된다

array[0] = 1;
array[1] = 56;
array[2] = 18;
```

> * 원소자료형: 모든 자료형 사용 가능
> * 배열이름: 식별자 생성 규칙에 따름
> * 배열크기
	* 초기값 지정이 없으면 반드시 양의 정수로 명시
	* 사용가능: 양의 정수(리터럴 상수, 매크로 상수, 리터럴 상수와 매크로 상수의 연산식)
	* 사용불가능: 변수, const 상수

<br>

* 배열선언초기화 - 배열선언과 값 초기화 동시에 하기

```c
원소자료형 배열이름[배열크기] = {원소값1, 값2, 값3, ...}

//중괄호를 이용한 초기화 방법은 배열선언 시 딱 한 번만 사용할 수 있음
```

```c
int grade[4] = {10, 2, 5, 4};
double output[] = {10.1, 432.6, 99.0};

//지정되지 않은 원소의 초기값은 기본값이 저장
//정수형 0, 실수형 0.0, 문자형 '\0\
int value[5] = {1, 2, 3};	

//부분 초기화
int init_part[5] = {[1] = 5, [4] = 2};	//0, 5, 0, 0, 2 저장
```

> * 배열크기: 생략가능, 생략 시 원소값의 수가 배열크기가 됨
> * 중괄호 `{}`
	* 명시된 배열 크기를 넘지 않게 원소값 나열 가능
	* 넘으면 배열 저장공간을 벗어나 문법 오류 발생
> * 원소값 나열: 전체를 중괄호`{}`로 묶고, 콤마`,`를 사용해 나열
> 

<br>
<br>


**2) 배열원소 참조하기** 👉 배열이름 뒤, 대괄호 사이 index(첨자)를 이용
* 유효한 index 범위: `0부터 배열크기-1`, 유효범위를 벗어나 참조하면 문법오류 발생

```c
int score[3] = {1, 3, 5};
printf("score[2] = %d", score[2]);

//배열원소 일괄 출력하기
for(int i = 0; i < 3; i++)
{
	printf("score[%d] = %d\n", i, score[i]); 
}
```

<br>
<br>
<br>

---
## **2차원 배열과 3차원 배열**
### **2차원 배열**
**1) 2차원 배열이란** 👉 `테이블 형태`의 구조를 나타내도록 `행(row)`과 `열(column)`의 구조로 표현한 배열

<br>

**2) 2차원 배열 선언과 초기화**
* 선언: `자료형 배열이름[행크기][열크기]`
	*	배열선언 시 초기값을 지정하지 않으면: 행과 열 크기 필수
	*	배열크기: 리터럴 상수, 매크로 상수, 이들의 연산식만 가능
* 초기화
	* 중괄호를 중첩되게 이용하는 방법
	* 하나의 중괄호로 모든 초기값을 쉼표로 분리하는 방법

```c
//1. 중괄호를 중첩되게 이용해 배열선언 및 초기화하기
int score[2][3] = {
					{30, 40, 22},
					{90, 33}
				  };	//부족한 값은 기본값으로 채워진다
				  
//2. 하나의 중괄호로 배열선언 및 초기화하기
int score[2][3] = {30, 40, 22, 90, 33, 22};
int socre[][3] = {30, 40, 22, 90, 33, 22};	//열 크기는 반드시 입력한다
```


<br>

**3) 2차원 배열의 구조**
* 메모리 상 2차원 배열
	* 행과 열의 개념이 아닌 1차원과 같은 연속적인 메모리 공간에 저장됨
	* 행을 먼저 배치하는 `행 우선 배열(row major`

<br>

**4) 2차원 배열 원소 참조**

```c
for(int i = 0; i < ROWSIZE; i++)
{
	for(int j = 0; j < COLSIZE; j++)
		puts("td[%d][%d] = %d", i, j, td[i][j]);
}
```

<br>
<br>

### **3차원 배열**
**1) 3차원 배열의 선언과 초기화**

```c
//선언, 쓰레기 값이 들어있음
int thrred[2][2][3]; 2*2*3 = 12개 원소의 3차원 배열

threed[0][0][0] = 1;	//첫 번째 원소
threed[1][1][2] = 12; 	//마지막 원소


//선언과 초기화를 동시에
int score[][4][2] = {	//첫 번째 크기는 지정하지 않을 수 있음
						{
							{95, 85}, {85, 93}, {92, 75}, {90, 88}
						},
						{
							{92, 81}, {81, 93}, {62, 95}, {94, 89}
						},
					}

```

<br>
<br>
<br>

---
## **배열크기 연산**
### **배열크기 계산방법**
**1) 1차원 배열 크기 계산**

```c
//배열 전체 공간의 바이트 수
sizeof(배열이름);

//배열 원소 하나의 바이트 수
sizeof(배열원소);

//배열의 크기
sizeof(배열이름) / sizeof(배열원소);
```

<br>

**2) 2차원 배열 크기 계산**

```c
//배열 전체 원소 수
sizeof(배열이름) / sizeof(배열[0][0]);

//배열의 행 수
sizeof(배열이름) / sizeof(배열[0]);

//배열의 열 수
sizeof(배열[0]) / sizeof(배열[0][0]);
```

