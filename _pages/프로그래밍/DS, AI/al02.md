---
title: "[알고리즘] Ch1 - 2. 효율적인 알고리즘 분석의 중요성"
tags:
date: "2025-03-20"
thumbnail: "/assets/img/thumbnail/mun.jpg"

---


비효율적인 알고리즘 분석을 통해 효율적인 알고리즘 분석의 중요성을 알아보도록 한다!

<br>

# **💡 순차 탐색(Sequential Search) vs 이진 탐색(Binary Search)**  
## **[ 이진 탐색(Binary Search) ]**

> **while 루프에서 두 번 비교하는가, 한 번 비교하는가?**  
• while 루프에서 x와 S[mid]를 비교하는 과정이 **각 반복마다 두 번 발생**한다(단, x를 찾은 경우 제외) 
• 그러나 효율적인 어셈블리 언어(assembler) 구현에서는 **한 번만 비교하도록 최적화할 수 있음**
• 즉, S[mid]와의 비교 결과를 조건 코드(condition code)에 설정하고, 이를 기반으로 분기(branch)를 수행할 수 있음
• 이를 통해 while 루프 내에서 **한 번만 비교하는 방식으로 동작할 수 있음**

<br>

## **[ 이진 탐색 알고리즘에서 연속된 32개의 숫자 비교 횟수 ]**
- 아래 그림에서는 **배열의 32개 연속된 요소 중 특정 값을 찾는 과정**을 보여줌
- 이진 탐색에서는 매 반복마다 탐색 범위가 절반으로 줄어듦

<br>

## **[ 순차 탐색(Sequential Search) vs. 이진 탐색(Binary Search) 비교 ]**  

|배열 크기|순차탐색 비교 횟수|이진탐색 비교 횟수|
|:---:|:---:|:---:|
|**128**|128|8|
|**1,024**|1,024|11|
|**1,048,576**|1,048,576|21|
|**4,294,967,296**|4,294,967,296|33|

> **순차 탐색(Sequential Search)**
• 입력 크기 n이 증가할수록 비교 횟수가 **선형적(O(n))**으로 증가
• 4,294,967,296개의 요소가 있을 때, 4,294,967,296번 비교

> **이진 탐색(Binary Search)**
• 비교 횟수가 **로그(log₂(n))** 형태로 증가하여 매우 효율적임
• 4,294,967,296개의 요소가 있을 때, 단 33번의 비교



<br>
<br>
<br>

# **💡 피보나치 수열(The Fibonacci Sequence)**
**[ 피보나치 수열의 정의 ]**

$
f0 = 0
f1 = 1
fn = fn-1 + fn-2 (for n >= 2)
$

<br>

**[ 재귀적 방식 VS 반복적 방식 ]**

**[ 재귀적 방식의 피보나치 수열 ]**
> 처음 몇 개 항 계산**

$
f2 = f1 + f0 = 1 + 0 = 1
f3 = f2 + f1 = 1 + 1 = 2
f4 = f3 + f2 = 2 + 1 = 3
f5 = f4 + f3 = 3 + 2 = 5
...
$

<br>

**재귀적 방식의 비효율성 증명**
• 첫 7개의 값에서 n이 2씩 증가할 때 마다 계산해야하는 항의 개수가 2배 이상 증가 > 계산량이 기하급수적으로 증가

|n|0|1|2|3|4|5|6|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|계산해야하는 항의 개수|1|1|3|5|9|15|25|


<br>

**재귀호출 트리를 이용한 비효율성 증명**

```
               fib(5)
              /       \
        fib(3)        fib(4)
       /     \        /     \
   fib(1)   fib(2)  fib(2)  fib(3)
            /     \        /     \
       fib(0)  fib(1)  fib(1)  fib(2)
                            /     \
                       fib(0)  fib(1)
```

$
T(n) > 2 * T(n-2)
     > 2 * 2 * T(n-4)
     > 2 * 2 * 2 * T(n-6)
     ...
     > 2 * 2 * 2 * ... * T(0)
$



## **피보나치 수열의 n번째 항을 계산하는 알고리즘**  

**[ 정리 (Theorem)]**  
> 만약 $T(n)$이 피보나치 알고리즘의 재귀 트리에서 계산되는 항의 개수라면, $n\geq2$일 때 다음이 성립한다.  
  $T(n) \approx 2^{n/2}$


<br>

**[ 증명 (Proof) ]**  
**귀납법 기초(Base Case)**  
- 귀납법을 적용하기 위해 **두 개의 기초 사례**가 필요 
- $n = 2 $및 $n = 3 $에 대한 값:  
  $T(2) = 3 \approx 2^{2/2}$
  $T(3) = 5 \approx 2^{3/2}$

**귀납 가설(Induction Hypothesis)**  
- 귀납 가설을 세우는 한 가지 방법은 **$m < n $인 모든 $m $에 대해 명제가 성립한다고 가정하는 것**.  
- 그런 다음, 귀납 단계에서 **이 가정이 $n $에 대해서도 성립함을 보이면 됨**.  
- 이 기법이 증명에 사용됨. 즉, $2 \leq m < n $인 모든 $m $에 대해:  
  $T(m) > 2^{m/2}$

**귀납 단계(Induction Step)**  
- $T(n) > 2^{n/2} $임을 보여야 함.  
- $T(n) $은 $T(n-1) $과 $T(n-2) $의 합, 그리고 루트 노드 1개로 구성됨.  

  $T(n) = T(n-1) + T(n-2) + 1$

  $
  > 2^{(n-1)/2} + 2^{(n-2)/2} + 1
  $

  $
  > 2^{(n-2)/2} + 2^{(n-2)/2} + 1
  $

  $
  = 2^{(n/2)} - 1
  $

- 따라서 **$T(n) > 2^{n/2} $가 성립함이 증명됨.**  



**반복적 방식 vs. 재귀적 방식의 실행 시간 비교**  

- **반복문을 활용하면 배열 $f $를 사용하지 않고도 알고리즘을 작성할 수 있음**.  
- **이전 두 개의 항만 필요하기 때문에, 배열 없이 구현 가능**.  
- **$fib2(n) $을 구하기 위해, 반복적 알고리즘은 첫 $n+1 $개의 항을 한 번씩만 계산**.  
  - 즉, **총 $n+1 $개의 계산이 필요**.  
  - **가정:** 한 항의 계산 시간이 **1ns**라고 가정.  


**실행 시간 비교표**  

| $n $| 반복적 방식에서 계산된 항 ($n+1 $) | 재귀적 방식에서 계산된 항 ($2^{n/2} $) | 알고리즘 1.7을 사용할 때 실행 시간 | 알고리즘 1.6을 사용할 때 실행 시간 |
|------|------------------|------------------|------------------|------------------|
| 40   | 41              | 1,048,576        | 41 ns           | 1048 μs          |
| 60   | 61              | $1.1 \times 10^9 $| 61 ns | 1 s |
| 80   | 81              | $1.1 \times 10^{12} $| 81 ns | 18 min |
| 100  | 101             | $1.1 \times 10^{15} $| 101 ns | 13 days |
| 120  | 121             | $1.2 \times 10^{18} $| 121 ns | 36 years |
| 160  | 161             | $1.2 \times 10^{24} $| 161 ns | $3.8 \times 10^7 $years |
| 200  | 201             | $1.3 \times 10^{30} $| 201 ns | $4 \times 10^{13} $years |

---

### **📌 결론**  
- **반복적 방식(Iterative Approach)**은 **선형 시간 $O(n) $** 으로 수행됨.  
- **재귀적 방식(Recursive Approach)**은 **지수 시간 $O(2^n) $** 으로 매우 비효율적.  
- **반복적 방식이 훨씬 빠르며, 큰 $n $에서 실행 시간이 엄청난 차이를 보임**.


<br>
<br>
<br>

# **알고리즘 분석**
---
## **복잡도분석**
> 1단계: **입력 크기 결정하기**
2단계: **기본 연산 선택하기**

<br>

**입력크기(input size) 결정하기**
일반적으로 알고리즘의 실행 시간은 입력 크기(input size)가 증가함에 따라 증가하며, 전체 실행 시간은 기본 연산(basic operation)이 수행되는 횟수와 비례함.

따라서, 알고리즘의 효율성은 기본 연산이 입력 크기의 함수로 몇 번 수행되는지를 분석하는 것으로 결정됨.

대부분의 알고리즘에서는 입력 크기를 정의할 수 있는 합리적인 방법을 찾을 수 있음.
입력 크기 ≠ 입력의 크기 자체
이진 표현(binary representation)을 사용할 경우, 입력 n을 인코딩하는 데 필요한 비트 수는 lg(n)+1
예를 들어, n=13일 경우, 이진수 표현은 1101이며, 입력 크기 = 4비트

<br>

**기본연산 선택하기**
✔ 알고리즘 내에서 특정 명령어 또는 명령어 그룹을 선택할 것
알고리즘이 수행하는 총 작업량은 특정 기본 연산이 몇 번 수행되는지에 비례
예를 들어, 순차 탐색(sequential search) 또는 이진 탐색(binary search) 알고리즘에서 **비교 연산(comparison instruction)**이 반복적으로 수행됨
기본 연산이 알고리즘 내에서 몇 번 수행되는지를 결정함으로써, 두 알고리즘 간의 상대적인 효율성을 분석할 수 있음



<br>
<br>

## **복잡도 분석의 일반적인 방식**
✔ 알고리즘의 시간 복잡도 분석
입력 크기에 대해 기본 연산이 몇 번 수행되는지 결정
알고리즘이 어떻게 구현되었는지에 대한 세부 사항은 고려하지 않으며, 기본 연산이 최대한 효율적으로 구현된다고 가정

✔ 두 개의 기본 연산을 고려해야 할 수도 있음
예시: 키 값을 비교하면서 정렬하는 알고리즘에서는
비교 연산(comparison instruction)
할당 연산(assignment instruction)
이 두 개의 연산을 각각 기본 연산으로 고려 가능
따라서, 각 연산이 몇 번 수행되는지를 개별적으로 분석하면 알고리즘의 효율성을 보다 명확하게 파악할 수 있음

**주의! 하면 안될 것**
❌ 알고리즘의 효율성을 종속적인 요인에 따라 분석하지 말 것(입력크기는 독립적)
특정 컴퓨터에서 실행될 때의 CPU 사이클 수는 알고리즘의 성능을 결정하는 기준이 될 수 없음.
프로그래밍 언어 또는 개발자의 코드 스타일에 따라 실행되는 명령어 수가 달라지므로 모든 명령어를 개별적으로 계산하는 것은 적절하지 않음.

❌ 기본 연산의 반복 횟수를 증가시키는 단순한 루프 제어 명령어는 포함하지 말 것
예를 들어, 루프를 제어하는 인덱스를 증가시키고 비교하는 연산은 고려 대상에서 제외
기본 연산의 횟수를 셀 때, 반복문의 한 번 실행을 기본 연산의 한 번 수행으로 간주할 수도 있음

<br>
<br>

## **시간복잡도 분석**

**[ Every-Case Time Complexity ]**

배열 요소 더하기(Add Array Members)’ 예제
기본 연산: 배열의 각 항목을 합(sum)에 추가하는 연산
입력 크기: n (배열 내 항목의 개수)
배열 내 숫자의 값과 관계없이, for 루프를 n번 반복

따라서, 기본 연산은 항상 n번 수행되며, 시간 복잡도는 다음과 같이 나타냄: T(n)=n
<br>
‘교환 정렬(Exchange Sort)’ 예제
앞서 설명했듯이, 키 값을 비교하는 정렬 알고리즘의 경우
비교 연산(comparison instruction)
할당 연산(assignment instruction)
이 두 연산을 각각 기본 연산으로 고려할 수 있음
여기서는 비교 연산 횟수를 분석
🔹 기본 정보
기본 연산: S[j]와 S[i] 비교
입력 크기: n (정렬할 항목의 개수)

🔹 for 루프의 반복 횟수 분석
외부 루프(for-i 루프)는 n−1번 반복
내부 루프(for-j 루프)는 첫 번째 반복에서 n−1번 실행
두 번째 반복에서 n−2번 실행
세 번째 반복에서 n−3번 실행
…
마지막 반복에서는 1번 실행
따라서, for-j 루프의 총 실행 횟수는 다음과 같이 계산됨: $T(n)=(n−1)+(n−2)+(n−3)+⋯+1$
이것은 등차수열의 합 공식을 사용하여: $T(n)= (n−1)⋅n/2$
​
 
따라서 교환 정렬(Exchange Sort)의 시간 복잡도는 $O(n^2)$



<br>
Matrix Multiplication (행렬 곱셈)
기본 연산: 가장 안쪽 for 루프에서 곱셈 연산 수행
입력 크기: n, 행과 열의 개수
설명:
for-i 루프에서 n번 실행됨
각 for-j 루프에서 n번 실행됨
각 for-k 루프에서도 n번 실행됨
따라서, 총 실행 횟수는 $T(n)=n×n×n=n^3$ 
 
<br>
<br>

**[ Worst-Case Time Complexity (최악의 경우 시간 복잡도) ]**
Sequential Search (순차 탐색)
기본 연산: 배열 내 요소를 x와 비교
입력 크기: n, 배열 내 요소 개수
설명:
최악의 경우 x가 배열의 마지막 요소이거나 배열 내 존재하지 않는 경우
기본 연산이 최대 n번 실행됨
따라서, 시간 복잡도는 $W(n)=n$


<br>
Average-Case Time Complexity (평균적인 경우의 시간 복잡도)
개요
정의: A(n)은 입력 크기가 n일 때 알고리즘이 기본 연산을 수행하는 평균 횟수
평균적인 경우의 시간 복잡도 분석을 통해 A(n)을 구함
관계: T(n)이 존재하면, A(n) = T(n)
Sequential Search (순차 탐색)
기본 연산: 배열 내 요소를 x와 비교
입력 크기: n, 배열 내 요소 개수
설명:
x가 배열 내 존재한다고 가정하면, 배열 내 모든 위치에 있을 확률이 동일함
x가 k번째 슬롯에 위치할 확률은 1/n
x를 찾기 위해 기본 연산이 k번 실행됨
따라서, 평균 시간 복잡도는
A(n)= 
k=1
∑
n
​
 k× 
n
1
​
 = 
n
1
​
 × 
k=1
∑
n
​
 k= 
2n
n(n+1)
​
 = 
2
n+1
​
Sequential Search (순차 탐색, x가 배열에 없을 수도 있는 경우)
설명:
x가 배열 내 존재할 확률 p를 가정
x가 k번째 슬롯에 있을 확률은 p/n
x가 존재하지 않을 확률은 1-p
x가 존재하면 k번 실행, 존재하지 않으면 n번 실행
따라서, 평균 시간 복잡도는
𝐴
(
𝑛

A(n)= 
k=1
∑
n(k× np
​
 )+n(1−p)
=
𝑝
𝑛
×
𝑛
(
𝑛
+
1
)
2
+
𝑛
(
1
−
𝑝
)
=
𝑛
(
1
−
𝑝
2
)
+
𝑝
2
= 
n
p
​
 × 2n(n+1)+n(1−p)=n(1−2p )+ 2p
​

특수한 경우:
p = 1이면, A(n) = (n+1)/2
p = 1/2이면, A(n) = 3n/4 + 1/4, 즉 평균적으로 배열의 3/4을 탐색


<br>


Best-Case Time Complexity (최선의 경우 시간 복잡도)
개요
정의: B(n)은 입력 크기가 n일 때 알고리즘이 기본 연산을 수행하는 최소 횟수
최선의 경우의 시간 복잡도 분석을 통해 B(n)을 구함
Sequential Search (순차 탐색)
기본 연산: 배열 내 요소를 x와 비교
입력 크기: n, 배열 내 요소 개수
설명:
x가 첫 번째 요소일 경우 한 번만 실행됨
따라서, 시간 복잡도는 B(n)=1





<br>
<br>

복잡도 함수

일반적인 개념
*복잡도 함수 (complexity function)*는 양의 정수를 비음수 실수로 매핑하는 함수이다.
특정 알고리즘의 시간 복잡도 또는 메모리 복잡도를 지칭하지 않는 경우, 일반적으로 표준 함수 표기법을 사용한다. 예를 들면:
𝑓
(
𝑛
)
=
𝑛
f(n)=n
𝑓
(
𝑛
)
=
𝑛
2
f(n)=n 
2
 
𝑓
(
𝑛
)
=
log
⁡
𝑛
f(n)=logn
𝑓
(
𝑛
)
=
3
𝑛
2
+
4
𝑛
f(n)=3n 
2
 +4n



 알고리즘 분석 (Analysis of Algorithms)
기타 명령어 (Other Instructions)
오버헤드 명령어 (Overhead instructions)

반복문 실행 전 초기화 명령어 등
이러한 명령어의 실행 횟수는 입력 크기와 무관함.
제어 명령어 (Control instructions)

루프를 제어하기 위해 인덱스를 증가시키는 명령어 등
이러한 명령어의 실행 횟수는 입력 크기와 함께 증가함.


비교 예제:

두 개의 알고리즘이 동일한 문제를 해결한다고 가정하자.
첫 번째 알고리즘: 시간 복잡도 
𝑂
(
𝑛
)
O(n)
두 번째 알고리즘: 시간 복잡도 
𝑂
(
𝑛
2
)
O(n 
2
 )
첫 번째 알고리즘이 더 효율적으로 보이지만, 특정 컴퓨터에서는 기본 연산을 처리하는 속도 차이에 따라 실행 시간이 달라질 수 있다.
해결할 부등식:

𝑛
×
1000
𝑡
<
𝑛
2
×
𝑡
n×1000t<n 
2
 ×t


정확성 분석 (Analysis of Correctness)
요구 사항 (Requirement):
알고리즘이 제대로 동작하는지 검증하기 위해, 알고리즘이 의도한 대로 작동한다는 수학적 증명을 개발해야 한다.
