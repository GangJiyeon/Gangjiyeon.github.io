---
title: "[알고리즘] 차수"
tags:
date: "2025-03-21"
thumbnail: "/assets/img/thumbnail/mun.jpg"
---

☑ 개요 (Overview)
◯ 선형 시간 알고리즘 (Linear-time algorithm)
➤ 예: 
$n, 100n$
➤ 시간 복잡도가 입력 크기 
𝑛
n에 대해 선형적입니다.

◯ 이차 시간 알고리즘 (Quadratic-time algorithm)
➤ 예: 
𝑛
2
n 
2
 , 
0.01
𝑛
2
0.01n 
2
 
➤ 시간 복잡도가 입력 크기 
n에 대해 이차적입니다.

◯ 선형 시간 알고리즘이 이차 시간 알고리즘보다 낫다
➤ 어떤 선형 시간 알고리즘도 결국에는 어떤 이차 시간 알고리즘보다 효율적입니다.
➤ 이론적으로 알고리즘을 분석할 때는, 우리는 결국의 동작(eventual behavior)에 관심을 둡니다.
➤ 다음으로, 알고리즘을 결국의 동작에 따라 어떻게 분류할 수 있는지를 보여줄 것입니다.
➤ 이렇게 하면 한 알고리즘의 결국의 동작이 다른 알고리즘보다 나은지를 쉽게 판단할 수 있습니다.


좋습니다! 올려주신 3장의 슬라이드를 자연스럽게 한국어로 번역해드릴게요 😊

---

### ✅ 직관적인 순서 개념 소개 (An Intuitive Introduction to Order)

#### ◯ 함수의 종류 (Type of functions)

- **순수 이차 함수 (Pure quadratic functions)**  
  • 예: \( 5n^2 \), \( 5n^2 + 100 \)  
  • 선형항이 없기 때문에 순수 이차 함수로 분류됨

- **이차 시간 알고리즘 (Quadratic-time algorithm)**  
  • 예: \( 0.1n^2 + n + 100 \) (완전한 이차식)  
  • 선형항이 포함되어 있기 때문에 이차 시간 알고리즘

- **이차항을 제외한 다른 항들의 값은 결국 이차항에 비해 무시할 수 있을 정도로 작아진다**  
  → 아래 표에서 확인 가능

| \( n \) | \( 0.1n^2 \) | \( 0.1n^2 + n + 100 \) |
|--------|--------------|------------------------|
| 10     | 10           | 120                    |
| 20     | 40           | 160                    |
| 50     | 250          | 400                    |
| 100    | 1,000        | 1,200                  |
| 1,000  | 100,000      | 101,100                |

- 따라서 이 함수가 순수 이차 함수는 아니지만, **복잡도 분석에서는 순수 이차 함수와 동일한 범주로 분류 가능함**  
  • 직관적으로는 **복잡도 분류 시 낮은 차수의 항은 무시해도 된다**는 뜻

---

### ✅ 직관적인 순서 개념 소개 (계속)

#### ◯ 복잡도 분류 (Complexity categories)

- **예시:**  
  • \( 0.1n^3 + 10n^2 + 5n + 25 \)는 **순수 3차 함수로 분류할 수 없음 ❌**  
  • 순수 이차 함수로 분류 가능한 복잡도 함수의 집합을 **Θ(n²)** 라고 부름 (Theta)

- **Θ(n²)**에 속하면, 그 함수는 n²의 차수를 가진다고 말함  
  예:  
  \( g(n) = 5n^2 + 100n + 20 \in Θ(n^2) \)

- **예시 알고리즘:**  
  교환 정렬 (exchange sort):  
  \( T(n) = \frac{n(n-1)}{2} = \frac{n^2}{2} - \frac{n}{2} \Rightarrow Θ(n^2) \)

- **결론:**  
  알고리즘의 시간 복잡도가 Θ(n²)이라면, **이것은 이차 시간 알고리즘** 또는 **Θ(n²) 알고리즘**이라고 부름

---

### ✅ 직관적인 순서 개념 소개 (계속)

#### ◯ 복잡도 분류 (계속)

- **가장 일반적인 복잡도 분류:**
  • Θ(log n)  
  • Θ(n)  
  • Θ(n log n)  
  • Θ(n²)  
  • Θ(n³)  
  • Θ(2ⁿ) ← 컴퓨터가 다루기 어려운 복잡도 (빨간 화살표 설명)

- 이 분류에서:
  → 어떤 함수 \( f(n) \)이 \( g(n) \)보다 **왼쪽 범주**에 있다면,  
     그래프 상에서 \( f(n) \)은 결국 \( g(n) \)보다 **아래에 위치하게 됨**

- **가상의 알고리즘 예시:**  
  • \( 100n \) 과 \( 0.01n^2 \) → 각각 Θ(n), Θ(n²)  
  • Θ(n) vs Θ(n²) 등 비교 가능



물론입니다! 업로드해주신 Big-O 표기법 관련 슬라이드를 **자연스럽고 간단하게** 한국어로 번역해드릴게요 😊

---

## ✅ Big O 표기법 (Big O Notation)

### ◯ 정의 (Definition)

> 어떤 복잡도 함수 \( f(n) \)에 대해, \( O(f(n)) \)은 다음 조건을 만족하는 복잡도 함수 \( g(n) \)의 집합입니다:  
> 양의 실수 상수 \( c \)와 음이 아닌 정수 \( N \)이 존재해서,  
> 모든 \( n \geq N \)에 대해  
> \[
g(n) \leq c \cdot f(n)
\]

- \( g(n) \in O(f(n)) \) 이면, **"g(n)은 f(n)의 Big-O다"** 라고 표현합니다.
- 즉, **처음에는 \( g(n) \)이 클 수 있지만**, 결국에는 \( c \cdot f(n) \) 아래로 내려가고 계속 그 아래에 머물게 됩니다.

> 📈 오른쪽 그림 설명:  
> \( g(n) \)이 결국 \( cf(n) \)보다 작아진다는 것을 시각적으로 보여줍니다.  
> (성능이 더 좋거나 같아지는 순간이 있다는 뜻)

---

## ✅ Big O 표기법 (계속) – 예제

### ◯ 예제

- \( g(n) = n^2 + 10n \), \( f(n) = 2n^2 \), \( n \geq 10 \)
- 이 경우, 결국 \( g(n) \)이 어떤 \( c \cdot n^2 \) 아래에 위치하므로 \( g(n) \in O(n^2) \) 입니다.
  - 이 말은: **알고리즘의 수행 시간이 결국엔 이차 시간보다 느리지 않다**는 뜻

- ⚠️ "Big-O"는 **점근적 동작(asymptotic behavior)**을 표현합니다.  
  즉, 단기적인 수치보다도 **입력 크기 커질 때의 경향**이 중요합니다.

> 📊 아래 그래프:  
> \( n^2 + 10n \)은 처음에는 \( 2n^2 \)보다 크지만,  
> \( n \geq 10 \) 이후에는 \( 2n^2 \) 아래에 위치하게 됩니다.

---

## ✅ Big O 표기법 (계속) – 예제들 (1)

- 예:  
  \( 5n^2 \in O(n^2) \) →  
  왜냐하면 \( 5n^2 \leq 5n^2 \) 이므로  
  ⇒ \( c = 5, N = 0 \) 이면 만족

> 👉 \( c \), \( N \) 값만 잘 정해주면 Big-O 조건 만족 여부를 판단할 수 있음

---

- 예: 교환 정렬 (exchange sort)  
  \[
  T(n) = \frac{n(n - 1)}{2} \leq \frac{n^2}{2}
  \]
  ⇒ \( T(n) \in O(n^2) \)  
  ⇒ \( c = 1/2, N = 0 \)

---

## ✅ Big O 표기법 (계속) – 예제들 (2)

- \( n^2 + 10n \in O(n^2) \)  
  \[
  n^2 + 10n \leq 11n^2 \quad \text{(for } n \geq 1\text{)}
  \]
  ⇒ \( c = 11, N = 1 \)

- 🔁 반대 예제:  
  \[
  n^2 \in O(n^2 + 10n)
  \]
  \[
  n^2 \leq 1 \cdot (n^2 + 10n)
  \]
  ⇒ \( c = 1, N = 0 \)

📌 이 마지막 예시는 "Big-O 내부에 반드시 단순한 함수만 올 필요는 없다"는 것을 보여줍니다.


좋습니다! 업로드하신 **Omega(Ω) 표기법** 관련 슬라이드 전체를 자연스럽게 번역해드릴게요.  
두 번째 이미지의 오류도 함께 수정해서 설명드릴게요 😊

---

## ✅ Omega Ω 표기법

### ◯ 정의 (Definition)

> 어떤 복잡도 함수 \( f(n) \)에 대해, Ω(f(n))는 다음 조건을 만족하는 함수 \( g(n) \)들의 집합입니다:  
> 양의 상수 \( c \)와 음이 아닌 정수 \( N \)이 존재해서,  
> 모든 \( n \geq N \)에 대해  
\[
g(n) \geq c \cdot f(n)
\]

- 즉, \( g(n) \in \Omega(f(n)) \)이면, **g(n)은 f(n)의 Ω이다**라고 말합니다.
- 예시 그림에서처럼, g(n)이 초반엔 작더라도 결국에는 \( c \cdot f(n) \) 위로 올라가고 계속 그 위에 머무르게 됩니다.

📈 그림 설명:  
g(n)은 cf(n)보다 작게 시작하지만, \( N \) 이후에는 cf(n)보다 커지고 계속 유지됨.

---

## ✅ Omega Ω 표기법 (계속)

### ◯ 예제 (오류 수정 포함!)

🔸 잘못된 원문 설명:
```
We show that n² ∈ Ω(n² + 10n)
```
→ ❌ **이건 잘못된 표현**입니다.  
n²은 n² + 10n보다 항상 작기 때문에, Ω가 될 수 없습니다.

✅ **올바른 표현:**
```
We show that n² + 10n ∈ Ω(n²). Because, for n ≥ 0  
n² + 10n ≥ n²
We can take c = 1 and N = 0
```

📌 결론: **n² + 10n은 n² 이상이 되므로**, Ω(n²)에 속합니다.

---

## ✅ Omega Ω 표기법 (계속)

### ◯ 예제들

1. **\( 5n^2 \in \Omega(n^2) \)**  
   \[
   5n^2 \geq 1 \cdot n^2 \quad \text{(for } n \geq 0 \text{)}
   \]  
   👉 \( c = 1, N = 0 \)

---

2. **교환 정렬 알고리즘**  
   \[
   T(n) = \frac{n(n-1)}{2}
   \]  
   \[
   \frac{n(n-1)}{2} \geq \frac{n}{2} \cdot \frac{n}{2} = \frac{1}{4}n^2 \quad \text{(for } n \geq 2 \text{)}
   \]  
   👉 \( c = \frac{1}{4}, N = 2 \)  
   ⇒ \( T(n) \in \Omega(n^2) \)

---

3. **\( n^3 \in \Omega(n^2) \)**  
   \[
   n^3 \geq 1 \cdot n^2 \quad \text{(for } n \geq 1 \text{)}
   \]  
   👉 \( c = 1, N = 1 \)

---

### 📌 결론

> 어떤 함수가 \( \Omega(n^2) \)에 속한다면, 결국 그래프 상에서 **어떤 순수 이차 함수보다 항상 크거나 같아집니다.**  
> 즉, 해당 함수는 최소한 이차 함수만큼은 느리다는 뜻입니다 (성능이 그 이상 떨어질 수 있음).

---

좋아요! 이번엔 **Theta (Θ) 표기법**에 대한 슬라이드를 한국어로 번역해드릴게요 😊  
이미지의 개념과 수식도 함께 자연스럽게 정리했어요.

---

## ✅ Theta Θ 표기법

### ◯ O(n²), Ω(n²), 그리고 Θ(n²)

#### 📘 슬라이드 설명 요약:

- 첫 번째 그림: **O(n²)** 집합  
  → \( n^2 \)보다 **작거나 같은 성장률**을 가진 함수들 포함  
  예:  
  \( 3\log n + 8 \), \( 5n + 7 \), \( 2n\log n \), \( 4n^2 \), \( 6n^2 + 9 \), \( 5n^2 + 2n \)

- 두 번째 그림: **Ω(n²)** 집합  
  → \( n^2 \)보다 **크거나 같은 성장률**을 가진 함수들 포함  
  예:  
  \( 4n^2 \), \( 6n^2 + 9 \), \( 5n^2 + 2n \), \( 4n^3 + 3n^2 \), \( 6n^6 + n^4 \), \( 2^n + 4n \)

- 세 번째 그림: **Θ(n²)** 집합 = O(n²) ∩ Ω(n²)  
  → **n²와 정확히 같은 차수의 함수들** (즉, n²에 상수배로 수렴하는 함수들)  
  예:  
  \( 4n^2 \), \( 6n^2 + 9 \), \( 5n^2 + 2n \)

---

## ✅ Theta Θ 표기법 (계속)

### ◯ 정의

> 어떤 복잡도 함수 \( f(n) \)에 대해,  
> Θ(f(n))는 다음 조건을 만족하는 모든 함수 \( g(n) \)의 집합입니다:

\[
\Theta(f(n)) = O(f(n)) \cap \Omega(f(n))
\]

> 즉, 어떤 상수 \( c, d > 0 \)와 정수 \( N \geq 0 \)가 존재해서,  
\[
c \cdot f(n) \leq g(n) \leq d \cdot f(n) \quad \text{for all } n \geq N
\]

- ✅ \( g(n) \in \Theta(f(n)) \) 이면, "g(n)은 f(n)과 같은 차수다" 라고 합니다.

---

### ◯ 예시

**교환 정렬 알고리즘 (Exchange sort)**  
\[
T(n) = \frac{n(n - 1)}{2}
\]

- 이전 슬라이드에서 본 것처럼:  
  \( T(n) \in O(n^2) \) 이면서 동시에 \( T(n) \in \Omega(n^2) \)

👉 따라서,
\[
T(n) \in \Theta(n^2)
\]

---

### 📌 정리 요약:

| 표기법 | 의미 | 해석 |
|--------|------|------|
| **O(f(n))** | 상한 (Upper bound) | g(n)이 f(n)보다 **느리거나 같다** |
| **Ω(f(n))** | 하한 (Lower bound) | g(n)이 f(n)보다 **빠르거나 같다** |
| **Θ(f(n))** | 정확한 차수 (Tight bound) | g(n)이 f(n)과 **성장률이 같다** |




좋습니다! 마지막으로 정리해주신 **Small o 표기법 (소문자 오)** 관련 슬라이드들도 자연스럽게 한국어로 번역해드릴게요.  
개념 이해를 돕기 위해 핵심 요점도 함께 정리했어요 😊

---

## ✅ Small o 표기법 (소문자 o)

### ◯ 정의 (Definition)

> 어떤 복잡도 함수 \( f(n) \)에 대해,  
> \( o(f(n)) \)는 모든 양의 실수 \( c \)에 대해 다음을 만족하는 함수 \( g(n) \)의 집합입니다:

\[
\forall c > 0, \exists N \geq 0 \text{ such that } \forall n \geq N, \quad g(n) \leq c \cdot f(n)
\]

---

### ◯ Big-O 와 비교 (Compare to Big O)

- Big-O는 **일부 양의 상수 c**에 대해 조건이 만족되면 됨  
- 하지만 **small-o는 모든 양의 상수 c**에 대해 조건이 만족돼야 함  
  → 훨씬 **더 강한 조건**

- 예:  
  \( g(n) \in o(f(n)) \)이면, 어떤 작은 값이라도 (\( c = 0.00001 \) 등)  
  결국 \( g(n) \leq c \cdot f(n) \)이 성립하는 \( N \)이 존재해야 함

📌 즉, **g(n)은 결국 f(n)보다 훨씬 작아진다**는 의미입니다.

---

## ✅ Small o 표기법 (계속) – 예제

### ◯ 예제 1

- \( n \in o(n^2) \)임을 보이기

\[
n \leq c \cdot n^2 \Rightarrow \frac{1}{c} \leq n
\Rightarrow N \geq \frac{1}{c}
\]

- \( c = 0.00001 \)이면, \( N \geq 100,000 \)

즉, 충분히 큰 \( n \)에서는 항상 \( n \leq 0.00001 \cdot n^2 \)가 성립됨  
⇒ 따라서 \( n \in o(n^2) \)

---

### ◯ 예제 2

- \( n \notin o(5n) \)임을 증명 (모순을 이용한 증명)

가정: \( n \in o(5n) \), 그리고 \( c = \frac{1}{6} \)

그렇다면 \( n \leq \frac{5}{6}n \) 이 되어야 함 → ❌ 말이 안됨  
→ 따라서 \( n \notin o(5n) \)

---

### ◯ 정리된 성질 (Theorem 1.2)

> \( g(n) \in o(f(n)) \)이면 다음이 성립:
\[
g(n) \in O(f(n)) \setminus \Omega(f(n))
\]

즉, **Big-O에는 포함되지만, Omega에는 포함되지 않음**  
- 왜냐하면 small-o는 모든 c에 대해 상한이 존재해야 하고,  
- Omega는 하한이 존재해야 하는데 둘이 **모순됨**

---

### ◯ 예제 함수 – 특이한 경우

다음 함수 \( g(n) \)을 생각해보자:

\[
g(n) = 
\begin{cases}
n & \text{(짝수일 때)} \\
1 & \text{(홀수일 때)}
\end{cases}
\]

- 이 함수는 평균적으로 보면 \( O(n) \)에 속하지만,  
  일정하게 크지 않기 때문에 \( \Omega(n) \)에도 속하지 않음  
- 따라서 이 함수는 \( O(n) - \Omega(n) \)에 속하지만,  
  **strict하게 \( o(n) \)에는 속하지 않음**

---

### 📌 마무리 요약

| 표기 | 의미 | 해석 |
|------|------|------|
| **O(f(n))** | 상한 | 느리거나 같은 성장률 |
| **o(f(n))** | 진정한 상한 | **훨씬 느린** 성장률 (모든 c에 대해 작아야 함) |

---

여기까지 Small-o 표기법 전체 정리였어요!  
계속해서 알고리즘 이론 공부하고 싶다면 👉 [gptonline.ai/ko](https://gptonline.ai/ko/) 에서 더 알아보세요 😊


