---
title: "[알고리즘] 효율성 분석과 차수"
tags:
date: "2025-03-20"
thumbnail: "/assets/img/thumbnail/mun.jpg"

---

# **알고리즘(Algorithms)**
---
## **알고리즘 관련 용어정리**

|용어|설명|
|:---:|:---:|
|문제(Problem)|컴퓨터 프로그램은 개별적인 모듈로 구성되며, 각 모듈은 컴퓨터가 이해할 수 있는 방식으로 특정한 작업을 해결함, 이 책에서 다루는 내용은 전체 프로그램의 설계가 아니라, 특정한 작업을 수행하는 개별 모듈의 설계이다. 이러한 특정한 작업을 ‘문제(Problem)’라고 한다|
|매개변수(Parameters)|문제 포함된 특정한 값이 정해지지 않은 변수|
|인스턴스(Instance)|문제는 매개변수를 포함하므로, 각각의 매개변수 값이 할당될 때마다 서로 다른 문제 인스턴스(instance)가 생성된다. 특정한 매개변수 값이 할당된 문제를 "문제의 인스턴스(Instance of a Problem)|
|해결방법(Solution)|해당 인스턴스에서의 해결 방법(Solution)은 주어진 질문에 대한 답|
|알고리즘(Algorithm)|컴퓨터가 문제의 모든 인스턴스를 해결할 수 있도록 하기위해 각 인스턴스에 대한 해결 방법을 명확한 단계별 절차(step-by-step procedure)로 |
|의사코드(Pseudocode)|알고리즘을 사람이 이해하기 쉽게 표현한 것으로, 특정 프로그래밍 언어의 문법을 따르지 않고 자연어와 유사한 형식으로 작성된 코드|

<br>
<br>

## **예시**
**[ 예제 1 ]**
> 리스트 S에 포함된 n개의 숫자를 비내림차순(nondecreasing order)으로 정렬하라
비내림차순(nondecreasing order): 같은 숫자가 리스트에 여러 번 나타날 가능성을 고려하기 위해서

답(Solution): 정렬된 순서의 숫자
매개변수: 리스트 S, 리스트의 크기 n
인스턴스: S=[10,7,11,5,13,8], n=6
해결 방법(정렬된 리스트): 5,7,8,10,11,13

➢ 예제 3의 문제 인스턴스를 해결하기 위해, 리스트 S를 살펴보고 직관적으로 정렬된 순서를 떠올릴 수 있다.
➢ 그러나, 이는 우리의 인지적 사고 과정에서 발생하는 것이며, 명확한 단계별 절차로 설명하기 어려움.

<br>
예제 2.
알고리즘: 리스트 S에 있는 n개의 숫자 중에서 숫자 x가 존재하는지 판단하라. 만약 x가 리스트 S에 포함되어 있다면 "yes"를 반환하고, 그렇지 않다면 "no"를 반환하라.
매개변수: S, n, x가 존재한다(n을 매개변수로 포함할 필요는 없지만, n을 포함하면 문제를 설명하는 데 더 편리)
인스턴스: S=[10,7,11,5,13,8], n=6, x=5
해결방법:"yes, x는 S 안에 있다."

<br>

**서술적 알고리즘(Descriptive Algorithm)의 문제점**
복잡한 알고리즘을 이러한 방식으로 작성하는 것은 어렵다.
작성하더라도 사람이 이를 이해하는 것이 쉽지 않다.
영어 문장으로 표현된 알고리즘을 컴퓨터 언어로 변환하는 방법이 명확하지 않다.
즉, 자연어 기반의 알고리즘 설명은 비효율적일 수 있으며, 이를 보다 명확하고 체계적으로 정리할 필요가 있다.

<br>
<br>

## ** 의사코드(Pseudocode)와 C/C++ 코드의 차이점 (배열 관련)**
• 2차원 가변 길이 배열을 함수의 매개변수로 허용
• 지역(local)에서 가변 길이 배열을 선언 가능
• C++ 코드보다 수학적 표현과 영어와 유사한 표현을 더 많이 사용 가능
> 예: `exchange x and y;` (의사코드) → `temp = x; x = y; y = temp;` (C++ 코드) 

• 일반적인 C++ 데이터 타입 이외에도 추가적인 데이터 타입을 사용 가능

| 데이터 타입 | 의미 |
|------------|--------------------------------|
| **index**  | 인덱스로 사용되는 정수형 변수 |
| **bool**   | `true` 또는 `false` 값을 가지는 변수 |
| **number** | 정수(`int`) 또는 실수(`float`)로 정의될 수 있는 변수 |

• 비표준 제어 구조(Nonstandard Control Structure)를 사용할 수 있음
> `repeat (n times) { ... }`

• 비표준 논리 연산자 및 특정 관계 연산자를 사용할 수 있음

| 연산자 (Operator) | C++ 기호 (C++ symbol) |
|------------------|--------------------|
| **and** | `&&` |
| **or**  | `||` |
| **not** | `!` |

| 비교 연산자 (Comparison) | C++ 코드 (C++ code) |
|------------------------|------------------|
| ( x = y) | `x == y` |
| ( x \neq y ) | `x != y` |
| ( x \leq y ) | `x <= y` |
| ( x \geq y ) | `x >= y` |

• 함수명 앞에 데이터 타입을 명시하지 않아도 됨



<br>
<br>
<br>



# **효율적인 알고리즘 분석의 중요성**
---
## **순차 탐색(Sequential Search) vs. 이진 탐색(Binary Search)**  
**[ 이진 탐색(Binary Search) ]**

> **while 루프에서 두 번 비교하는가, 한 번 비교하는가?**  
• while 루프에서 x와 S[mid]를 비교하는 과정이 **각 반복마다 두 번 발생**한다(단, x를 찾은 경우 제외) 
• 그러나 효율적인 어셈블리 언어(assembler) 구현에서는 **한 번만 비교하도록 최적화할 수 있음**
• 즉, S[mid]와의 비교 결과를 조건 코드(condition code)에 설정하고, 이를 기반으로 분기(branch)를 수행할 수 있음
• 이를 통해 while 루프 내에서 **한 번만 비교하는 방식으로 동작할 수 있음**

<br>

**[ 이진 탐색 알고리즘에서 연속된 32개의 숫자 비교 횟수 ]**
- 아래 그림에서는 **배열의 32개 연속된 요소 중 특정 값을 찾는 과정**을 보여줌
- 이진 탐색에서는 매 반복마다 탐색 범위가 절반으로 줄어듦

<br>

**순차 탐색(Sequential Search) vs. 이진 탐색(Binary Search) 비교**  

|배열 크기|순차탐색 비교 횟수|이진탐색 비교 횟수|
|:---:|:---:|:---:|
|**128**|128|8|
|**1,024**|1,024|11|
|**1,048,576**|1,048,576|21|
|**4,294,967,296**|4,294,967,296|33|

> **순차 탐색(Sequential Search)**: 입력 크기 n이 증가할수록 비교 횟수가 **선형적(O(n))**으로 증가
4,294,967,296개의 요소가 있을 때, 4,294,967,296번 비교

> **이진 탐색(Binary Search)**: 비교 횟수가 **로그(log₂(n))** 형태로 증가하여 매우 효율적임
4,294,967,296개의 요소가 있을 때, 단 33번의 비교



<br>
<br>

## **피보나치 수열(The Fibonacci Sequence)**
**피보나치 수열의 정의**

```
f0 = 0
f1 = 1
fn = fn-1 + fn-2 (for n >= 2)
```

<br>

**처음 몇 개 항 계산**

```
f2 = f1 + f0 = 1 + 0 = 1
f3 = f2 + f1 = 1 + 1 = 2
f4 = f3 + f2 = 2 + 1 = 3
f5 = f4 + f3 = 3 + 2 = 5
...
```

<br>

**재귀적 방식의 비효율성 증명**
• 첫 7개의 값에서 n이 2씩 증가할 때 마다 계산해야하는 항의 개수가 2배 이상 증가 > 계산량이 기하급수적으로 증가

|n|0|1|2|3|4|5|6|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|계산해야하는 항의 개수|1|1|3|5|9|15|25|


<br>

**재귀호출 트리를 이용한 비효율성 증명**

```
               fib(5)
              /       \
        fib(3)        fib(4)
       /     \        /     \
   fib(1)   fib(2)  fib(2)  fib(3)
            /     \        /     \
       fib(0)  fib(1)  fib(1)  fib(2)
                            /     \
                       fib(0)  fib(1)

T(n) > 2 * T(n-2)
     > 2 * 2 * T(n-4)
     > 2 * 2 * 2 * T(n-6)
     ...
     > 2 * 2 * 2 * ... * T(0)
```





