---
title: "[알고리즘] 분할정복과 알고리즘"
categories:
  - ds_ai
tags: [알고리즘]
use_math: true
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---
<br>



# 분할 정복(Divide and Conquer)과 기본 알고리즘

## Divide and Conquer 개념 및 Top-Down 방식

**[ 분할정복법 ]**
> 문제를 더 작은 하위 문제로 나누고, 각 하위 문제를 독립적으로 해결한 뒤, 그 결과를 합쳐 원래 문제의 해답을 구하는 알고리즘 설계 기법<br>
• `Divide (분할)`: 문제를 더 작은 하위 문제로 나눔<br>
• `Conquer (정복)`: 하위 문제를 재귀적으로 해결<br>
• `Combine (결합)`: 하위 문제의 해를 이용해 전체 문제의 해를 구성

<br>

**[ top-down 방식 ]**<br>
> • 하나의 문제 인스턴스를 두 개 이상의 더 작은 인스턴스로 나눔<br>
• 더 작은 인스턴스들의 해답을 쉽게 구할 수 있으면, 이 해답을 결합하여 원래 문제의 해답을 얻을 수 있음

`참고` bottop-up 방식<br>
• 가장 작은 문제부터 시작해서 차례대로 큰 문제를 해결<br>
• 작은 문제의 결과를 저장하고 재사용 (동적 계획법에서 자주 사용)<br>
• 반복문을 이용해 구현됨<br>
• 예: 동적 계획법(Dynamic Programming), 피보나치 수열의 DP 구현


<br>
<br>

## Binary Search (이진 탐색) - 재귀적

**[ Binary Search 문제 ]**<br>
**`정의`** 정렬된(비감소 순서) 배열에서 키 `x`의 위치를 찾는 문제

**`방법`** 배열의 가운데 항목과 `x`를 비교함<br>
• 같으면 알고리즘 종료<br>
• 다르면 배열을 두 부분으로 나눔: 가운데 항목의 왼쪽 부분, 가운데 항목의 오른쪽 부분

**`핵심 단계`**  <br>
• 배열을 절반 크기의 두 부분으로 나눈다: `x`가 가운데보다 작으면 왼쪽 부분, 크면 오른쪽 부분 선택 <br>
• 해당 부분에서 `x`가 있는지 확인, 크기가 충분히 작지 않으면 재귀 호출 사용  <br>
• 해당 부분에서의 결과가 전체 배열에 대한 해답이 됨<br>
• `특이사항` 작은 인스턴스로 나누지만, 그들의 **출력을 결합하지 않음**

<br>

**[ 이진 탐색 알고리즘 설계 ]**<br>
**`기본 설계 원칙`**  <br>
• 더 작은 인스턴스의 해로부터 원래 문제의 해를 구하는 방법 개발  <br>
• 더 작은 인스턴스가 도달하게 될 종료 조건 설정  <br>
• 종료 조건에 해당하는 경우의 해 결정

**`프로그래밍 시 유의사항`**<br>
• 이 자료에서는 재귀 호출 중 값이 변할 수 있는 변수들만 재귀 루틴의 매개변수로 사용<br>
• **꼬리 재귀(tail-recursion)** 사용 요구: 재귀 호출 이후 연산 없음, 꼬리재귀를 반복문 기반 알고리즘으로 전환 시 메모리 효율성 ↑<br>
• `주의` 재귀 루틴의 경우, **스택에 쌓이는 activation record 수는 재귀 호출이 도달한 깊이에 따라 결정**

<br>

**[ 예시 ]**  
**`문제`** 정렬된 배열에서 `x = 18`을 찾는 과정

```
[10 12 13 14 18 20 25 27 30 35 40 45 47]

- 25와 비교 → x < 25 → 왼쪽 선택
- 13과 비교 → x > 13 → 오른쪽 선택
- 18과 비교 → x = 18 → 탐색 성공
```

**`의사코드`**

```c
/*
problem: 크기가 n인 정렬된 배열에서 x 찾기
input: 정수 n, 정렬된 배열 S[1...n], 탐색 키 x 
output: x가 있는 위치(없으면 0 반환)
*/
index location(index low, index high)
{
    index mid;
    if (low > high)
        return 0;
    else {
        mid = ⌊(low + high) / 2⌋;
        if (x == S[mid])
            return mid;
        else if (x < S[mid])
            return location(low, mid - 1);
        else
            return location(mid + 1, high);
    }
}
```

<br>

**[ 최악의 시간 복잡도 분석 ]**<br>
> $W(n) = W(n/2) + 1$<br>
• $W(n/2)$: 재귀호출에서의 비교<br>
• $1$: top level에서의 비교

👉 $t_n = \log_2 n + 1 \quad$ 몇 개의 값을 통해 확인<br>
$t_2 = t_{2/2} + 1 = t_1 + 1 = 1 + 1 = 2$<br>
$t_4 = t_{4/2} + 1 = t_2 + 1 = 2 + 1 = 3$<br>
$t_8 = t_{8/2} + 1 = t_4 + 1 = 3 + 1 = 4$<br>
$t_{16} = t_{16/2} + 1 = t_8 + 1 = 4 + 1 = 5$


|귀납법|적용|
|:---:|---|
|`귀납 기초 (Induction base)`|$t_1 = 1 = \log 1 + 1$|
|`귀납 단계 (Induction step)`|when $2n$ <br> • (재귀는 2의 거듭제곱에 대해서만 정의됨)<br> • $t_{2n} = \log 2n + 1$|
|`증명 과정`|$t_{2n} = t_{2n/2} + 1 = t_n + 1$<br>$= \log n + 1 + 1$<br>$= \log n + \log 2 + 1$<br>$= \log(2n) + 1$|




<br>
<br>

## Merge Sort (합병 정렬)

**[ 예시 ]**

<br>

**[ 의사코드: not in-place ]**<br>
`예시 1 - mergesort`

```c
// 문제: n개의 키를 비감소(non-decreasing) 순서로 정렬하라
// 입력: 양의 정수 n, 인덱스 1부터 n까지의 키 배열 S
// 출력: 비감소 순서로 정렬된 키들을 포함하는 배열 S
void mergesort (int n, keytype S[]) {
    if (n > 1) {
        const int h = ⌊n/2⌋, m = n - h;
        keytype U[1..h], V[1..m];

        // S를 절반씩 나누어 각각 U와 V로 복사
        copy S[1] through S[h] to U[1] through U[h];
        copy S[h+1] through S[n] to V[1] through V[m];

        // 각각 재귀적으로 정렬
        mergesort(h, U);
        mergesort(m, V);

        // 정렬된 두 배열을 병합
        merge(h, m, U, V, S);
    }
}
```


`예시 2 - merge`

```c
// 문제: 정렬된 두 배열을 하나의 정렬된 배열로 병합하라
// 입력: 양의 정수 h, m
//      인덱스 1부터 h까지의 정렬된 배열 U
//      인덱스 1부터 m까지의 정렬된 배열 V
// 출력: 인덱스 1부터 h + m까지의 정렬된 배열 S, U와 V의 모든 원소 포함

/*
inplace sort가 아니다
→ 정렬 과정에서 새로운 배열(U, V)을 계속 만들어서 공간을 추가로 사용함
→ 특히, 재귀 호출 중마다 메모리가 쌓이므로 활성 스택도 증가
*/
void merge (int h, int m, const keytype U[], const keytype V[], keytype S[]) {
    index i, j, k;
    i = 1; j = 1; k = 1;

    while (i <= h && j <= m) {
        if (U[i] < V[j]) {
            S[k] = U[i];
            i++;
        } else {
            S[k] = V[j];
            j++;
        }
        k++;
    }

    // 남은 요소 복사
    if (i > h)
        copy V[j] through V[m] to S[k] through S[h+m];
    else
        copy U[i] through U[h] to S[k] through S[h+m];
}
```

<br>

**[ 의사코드: in-place ]**<br>
`예시 1 - Mergesort 2`

```c
/*
문제: n개의 키를 비감소(non-decreasing) 순서로 정렬하라
입력: 양의 정수 n, 인덱스 1부터 n까지의 키 배열 S
출력: 정렬된 상태의 배열 S
*/

void mergesort2(index low, index high) {
    index mid;
    if (low < high) {
        mid = ⌊(low + high)/2⌋;
        mergesort2(low, mid);
        mergesort2(mid + 1, high);
        merge2(low, mid, high);
    }
}
```

`예시 2 - Merge 2`

```c
// U는 정렬을 위한 임시 배열 (in-place라 하더라도 공간은 일부 사용)
// 최종적으로 U의 내용을 다시 S로 복사 → 원본 배열이 정렬됨
/*
문제: Mergesort 2에서 생성된 두 정렬된 부분 배열을 병합하라
입력: 인덱스 low, mid, high
     배열 S[low..high] (두 부분 [low..mid], [mid+1..high]는 각각 정렬된 상태)
출력: 전체 범위 S[low..high]가 정렬된 상태로 병합됨
*/

void merge2(index low, index mid, index high) {
    index i, j, k;
    keytype U[low..high]; // 병합을 위한 임시 배열

    i = low; j = mid + 1; k = low;

    while (i <= mid && j <= high) {
        if (S[i] < S[j]) {
            U[k] = S[i];
            i++;
        } else {
            U[k] = S[j];
            j++;
        }
        k++;
    }

    if (i > mid) {
        move S[j] through S[high] to U[k] through U[high];
    } else {
        move S[i] through S[mid] to U[k] through U[high];
    }

    move U[low] through U[high] to S[low] through S[high];
}

```

<br>
<br>

## Quick Sort (퀵 정렬)

**[ 퀵 정렬 ]**
> 피벗을 기준으로 나누고, 각각 정렬하는 방식

<br>

**[ 예시 ]**

```c
    [15 22 13 27 12 10 20 25]
            /         |         \
    [10 13 12]     [15]    [22 27 20 25]
        /                      \
    [10]                  [20] [22] [27 25]
        \                             \
    [12 13]                         [25 27]
```

|배열내부|설명|
|---|---|
|`15 22 13 27 12 10 20 25`|처음|
|`10 13 12 [15] 22 27 20 25`|피벗(15)을 기준으로 배열 나누기<br>• 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽|
|`10 13 12 → 10 12 13`, `22 27 20 25 → 20 22 25 27`|두 부분 배열 각각 정렬|
|`15 22 13 27 12 10 20 25`|정렬|

<br>

**[ 시간 복잡도 ]**<br>
`Partition의 시간복잡도`: 입력 배열의 크기에 따라 $T(n) = n - 1$ (피벗 빼고 나머지 비교)

`최악의 경우 시간 복잡도`<br>
피벗이 항상 가장 작거나, 가장 큰 값일 경우<br>
• 정렬이 한쪽으로만 이루어짐<br>
• 왼쪽 서브배열(0개), 오른쪽 서브배열(n-1개)

• $W(n) = T(0) + T(n-1) + (n-1)$<br>
$T(0)$: 원소 n개를 정렬하는 데 걸리는 최악의 경우 시간<br>
$T(n)$: 왼쪽 부분 배열 정렬 시간 (비어있음 → 0)<br>
$T(n-1)$: 오른쪽 배열 정렬 시간 (피벗 제외 나머지 모두)<br>
$n-1$: 파티션 비용

• 재귀적 방정식<br>
$T(n) = T(n - 1) + n - 1, (for n > 0)$<br>
$T(0) = 0$<br>
solution: $T(n) = n(n-1)/2$ > $O(n^2)$ 시간복잡도


`평균의 경우 시간 복잡도`
> 모든 위치가 피벗이 될 확률이 동일($p = 1/n$)하다고 가정할 때, A(n)<br>
$A(n) = \sum_{p=1}^{n} \frac{1}{n} \left[ A(p-1) + A(n-p) \right] + (n - 1)$<br>
• 앞부분: 피벗 위치 p에 따라 양쪽 서브배열을 정렬하는 평균 시간<br>
• 뒤의 (n - 1)은 파티션하는 데 걸리는 시간

• 근사화하면 $A(n) \approx (n + 1) \cdot 2 \ln n \approx 1.38(n + 1)\log n \in \Theta(n \log n)$<br>
• 평균적으로 매우 효율적인 정렬 알고리즘

<br>

**[ 의사코드 ]**

```c
// 제자리 파티셔닝 방식이라 별도 배열 안 씀
// 선형 시간 복잡도
/*
문제: Quicksort를 위해 배열 S를 파티션(partition)하라
입력: 두 인덱스: low와 high, 배열 S[low ... high] (부분 배열)
출력: pivotpoint: 정렬 후 피벗이 위치하게 되는 인덱스
*/
void partition(index low, index high, index& pivotpoint) {
    index i, j;
    keytype pivotitem;

    // 피벗 항목을 배열의 첫 번째 원소로 선택
    pivotitem = S[low];
    j = low;

    // low+1부터 high까지 반복하며 파티션 수행
    for (i = low + 1; i <= high; i++) {
        if (S[i] < pivotitem) {
            j++;
            exchange S[i] and S[j]; // 작은 값들을 앞으로 모음
        }
    }

    // 피벗의 최종 위치를 저장
    pivotpoint = j;
    exchange S[low] and S[pivotpoint]; // 피벗을 제자리에 배치
}
```

<br>
<br>

## Factorial

```c
/*
문제: n! = n × (n-1) × (n-2) × ... × 3 × 2 × 1 (단, n ≥ 1), 0! = 1
입력: 음이 아닌 정수 n
출력: n!
*/
int fact(int n) {
    if (n == 0)
        return 1;
    else
        return n * fact(n - 1);
}
```



**[ 팩토리얼 알고리즘의 효율성 ]**<br>
**1) 곱셈 횟수를 재귀식(recurrence equation) 으로 표현**
`재귀 방정식: 재현식`
> $t_n = t_(n-1) + 1$<br>
• $t_n$: 재귀호출 시 곱셈 횟수<br>
• $1$: 최상위 수준에서의 곱셈 1회<br>
→ 함수의 값이 작은 n의 값을 이용해 큰 n의 값을 구함

**초기 조건**: $t_0 = 0$ (0! = 1이므로 곱셈 없음) <br>
**n이 클 때의 $t_n$ 계산 예시**<br>
• `t₁ = t₀ + 1 = 0 + 1 = 1`<br>
• `t₂ = t₁ + 1 = 1 + 1 = 2`<br>
• `t₃ = t₂ + 1 = 2 + 1 = 3`
결론: `tₙ`을 `t₀`부터 반복 계산하는 건 비효율적이다 → 

<br>
**2) 곱셈 횟수를 후보 해(candidate solution) 를 통해 구하기**
• $t_n$에 대한 명시적 표현(해)을 얻기: $t_n = t_(n-1) + 1$<br>
👉 귀납법으로 해를 찾는 것은 불가능하지만, 후보 해가 맞는지를 확인하는 데는 귀납법을 사용할 수 있음<br>
• 초반 몇 개 값을 확인

```c
t₁ = t₀ + 1 = 0 + 1 = 1
t₂ = t₁ + 1 = 1 + 1 = 2
t₃ = t₂ + 1 = 2 + 1 = 3
```

• 후보 해 추정: $t_n = n$

**3) 후보 해의 정당성 증명**<br>
`n = 0`: $t_0 = 0$<br>
`귀납가정(Induction Hypothesis)`: $t_n = n$<br>
`귀납단계(Induction Step)`: $t(n+1) = n + 1$이 참임을 증명<br>
`결론`: $t_(n+1) = t_((n+1)-1) + 1 = t_n + 1 = n + 1$


<br>
<br>
<br>

# 재귀식
## 재귀식이란


**[ 재귀식 예시 ]**<br>
**1) 예제 1**<br>

|구분|내용|
|:---:|---|
|**`주어진 재귀식`**|$t_n = t_{n/2} + 1$(단, \(n > 1\), \(n\)은 2의 거듭제곱)<br>$t_1 = 1$|
|**`점검 (Inspection)`**|$t_2 = t_{2/2} + 1 = t_1 + 1 = 1 + 1 = 2$  <br>$t_4 = t_{4/2} + 1 = t_2 + 1 = 2 + 1 = 3$<br>$t_8 = t_{8/2} + 1 = t_4 + 1 = 3 + 1 = 4$ <br>$t_{16} = t_{16/2} + 1 = t_8 + 1 = 4 + 1 = 5$|
|**`추정 (Estimation)`**|$t_n = \log n + 1$|
|**`정당성 증명 (Proof of the correctness)`**|$n = 1$일 때: $t_1 = 1 = \log 1 + 1$|
|**`귀납 가정 (Induction hypothesis)`**|$t_n = \log n + 1$|
|**`귀납 단계 (Induction step)`**|$2n$을 대입하여 다음을 보여야 함:<br>$t_{2n} = \log (2n) + 1$|
|**`결론`**|$t_{2n} = t_{(2n)/2} + 1 = t_n + 1 = \log n + 1 + 1$<br>$= \log n + \log 2 + 1$<br>$= \log (2n) + 1$|

<br>

**2) 예제 2**

|구분|내용|
|:---:|---|
|**주어진 재귀식**|$t_n = 7t_{n/2}$ (단, $n > 1,n$은 $2$의 거듭제곱)<br>$t_1 = 1$|
|**점검 (Inspection)**|$t_2 = 7t_{2/2} = 7t_1 = 7$<br>$t_4 = 7t_{4/2} = 7t_2 = 7^2$<br>$t_8 = 7t_{8/2} = 7t_4 = 7^3$<br>$t_{16} = 7t_{16/2} = 7t_8 = 7^4$|
|**추정 (Estimation)**|$t_n = 7^{\log n}$|
|**정당성 증명 (Proof of the correctness)**|$n = 1$ 일 때: $t_1 = 1 = 7^0 = 7^{\log 1}$|
|**귀납 가정 (Induction hypothesis)**|$t_n = 7^{\log n}$|
|**귀납 단계 (Induction step)**|$t_{2n} = 7^{\log (2n)}$|
|**결론 (Conclusion)**|$t_{2n} = 7t_{(2n)/2} = 7t_n = 7 \times 7^{\log n} = 7^{1 + \log n} = 7^{\log 2 + \log n} = 7^{\log (2n)}$<br>$\therefore t_n = n^{\log 7} \approx n^{2.81}$ (왜냐하면 $7^{\log n} = n^{\log 7}$)

<br>

**3)명확한 후보 해(candidate solution)가 없는 경우**

|구분|내용|
|:---:|---|
|**주어진 재귀식**|$t_n = 2t_{n/2} + n - 1$ (단, $n > 1, n$은 2의 거듭제곱)<br>
$t_1 = 0$|
|**점검 (Inspection)**|$t_2 = 2t_{2/2} + 2 - 1 = 2t_1 + 1 = 1$<br>$t_4 = 2t_{4/2} + 4 - 1 = 2t_2 + 3 = 5$<br>$t_8 = 2t_{8/2} + 8 - 1 = 2t_4 + 7 = 17$<br>$t_{16} = 2t_{16/2} + 16 - 1 = 2t_8 + 15 = 49$|
|**추정 (Estimation)**|???|

<br>

**[ 재귀식의 종류 ]**<br>
선형 동차(동질) 재귀식 (Homogeneous Linear Recurrence)

`예시`<br>
동차 선형 상수 계수 재귀식<br>
(Homogeneous Linear Recurrence Equations with Constant Coefficients)<br>
$7t_n - 3t_{n-1} = 0$<br>
$6t_n - 5t_{n-1} + 8t_{n-2} = 0$<br>
$8t_n - 4t_{n-3} = 0$


비동차(비동질) 재귀식 (Nonhomogeneous Recurrence)

비동차 선형 점화식(Nonhomogeneous Linear Recurrences)

#### ✅ 정의 (Definition)

다음 형태의 점화식:
$a_0 t_n + a_1 t_{n-1} + \cdots + a_k t_{n-k} = f(n)$

여기서 $k$와 $a_i$들은 상수이고 $f(n)$은 0이 아닌 어떤 함수일 때, 이러한 식은 **상수 계수를 갖는 비동차 선형 점화식(nonhomogeneous linear recurrence equation with constant coefficients)** 이라고 부른다.


- **영 함수 (Zero function)**: $f(n) = 0$
- 비동차 점화식을 푸는 일반적인 방법은 **알려져 있지 않음**
- 그러나 **자주 나오는 특수한 경우**에 대해 방법이 존재함:

$a_0 t_n + a_1 t_{n-1} + \cdots + a_k t_{n-k} = b^n p(n)$

> $b4: 상수, $p(n)$: $n $에 대한 다항식



**[ 용어 정리 ]**
후보해 (Candidate Solution): 문제를 풀기 위해 가설로 세운 해 (검증 필요)
일반해 (General Solution): 재귀식 전체를 만족하는 해, 상수 포함해서 모든 해를 나타내는 형태


**[ 정리 ]**

|정리 B.1 (Theorem B.1)|

$a_0t_n + a_1t_{n-1} + ... + a_kt_{n-k} = 0$<br>
👉 여기서 $k$와 각 $a_i$들은 상수일 때, 이를
상수 계수로 갖는 동차 선형 재귀식<br>
• 선형(linear)인 이유: 모든 항 $t_1$가 1차로만 등장하기 때문<br>
• 다음 항은 포함하지 않음: $t_{2n-i}, t_{n-1}t{n-j}$<br>
• $c$가 1이 아닌 양의 상수일 경우, 다음 항도 포함하지 않음: $t_{c(n-i)}$

|정리 B.2 (Theorem B.2)|
|---|
|• $r$이 상수 계수를 가진 동차 선형 점화식의 특성 방정식의 중복도 $m$을 가진 근이라면,<br>
• $t_n = r^n, \quad t_n = n r^n, \quad t_n = n^2 r^n, \quad t_n = n^3 r^n, \quad \dots, \quad t_n = n^{m-1} r^n
$ 는 모두 점화식의 해가 됨<br>
• 그러므로 이러한 해 각각은 점화식의 일반해(정리 B.1에서 제시됨)에 포함|


|정리 B.3 (Theorem B.3)|
|---|
|다음 형태의 비동차 선형 점화식: $a_0 t_n + a_1 t_{n-1} + \cdots + a_k t_{n-k} = b^n p(n)$

은 다음과 같은 특성 방정식을 갖는 동차 선형 점화식으로 변환할 수 있다:
$(a_0 r^k + a_1 r^{k-1} + \cdots + a_k)(r - b)^{d+1} = 0$

여기서 \( d \)는 \( p(n) \)의 차수(Degree)이다. 이 특성 방정식은 두 부분으로 이루어진다:

1. 해당 동차 점화식의 특성 방정식
2. 비동차 항으로부터 유도된 항

만약 오른쪽 항에 \( b^n p(n) \) 같은 항이 둘 이상 있다면, 각각의 항이 특성 방정식에 하나의 항을 더하게 된다.



## 특성 방정식을 이용한 재귀식 풀이 
(Solving Recurrences Using the Characteristic Equation)


**[ 예시 ]**<br>

피보나치 수열의 재귀식 (Fibonacci sequence recurrence equation)
$t_n = t_{n-1} = t_{n-2}$<br>
$t_0 = 0$, $t_1 = 1$

동차 선형 재귀식 형태로 표현: $t_n - t_{n-1} - t_{n-2} = 0$




### **특성 방정식을 이용한 재귀식 풀이**  
**Solving Recurrences Using the Characteristic Equation**


**[ 동차 선형 재귀식 예제로부터 재귀식 풀기 ]**

|단계|내용|
|:---:|---|
|**주어진 재귀식**|$t_n - 5t_{n-1} + 6t_{n-2} = 0$ for $n > 1$<br>$t_0 = 0, t_1 = 1$|
|**가정**|$t_n = r^n$<br>$t_n - 5t_{n-1} + 6t_{n-2} = r^n - 5r^{n-1} + 6r^{n-2} = 0$<br>$r^n - 5r^{n-1} + 6r^{n-2} = 0 \Rightarrow r^{n-2}(r^2 - 5r + 6) = 0$|
|**해**|$r = 0$, $r = 3$, $r = 2$|
|**결론**|$t_n = 0$, $t_n = 3^n$,$t_n = 2^n$|
|**검증**|$t_n = 3^n$,$t_{n-1} = 3^{n-1}$,$t_{n-2} = 3^{n-2}$<br>$t_n - 5t_{n-1} + 6t_{n-2}$<br>$3^n - 5(3^{n-1}) + 6(3^{n-2}) = 3^n - 3(3^{n-1}) = 3^n - 3^n = 0$<br>$t_n = 2^n$가 해인지도 확인함|

**일반해 (General Solution)**  
$t_n = 0$, $t_n = 3^n$, $t_n = 2^n$이 해이므로 **재귀식의 일반해는 다음과 같음**<br>
$t_n = c_1 3^n + c_2 2^n$(단, $c_1$, $c_2$는 임의의 상수)<br>
$c_1 = c_2 = 0$일 경우, $t_n = 0$<br>

일반해를 완성하려면 **초기 조건을 대입하여 $c_1, c_2$** 를 결정<br>

**초기 조건** $t_0 = 0$,$t_1 = 1$

**식 정리**:  
$t_0 = c_1 3^0 + c_2 2^0 = c_1 + c_2 = 0$
$t_1 = c_1 3^1 + c_2 2^1 = 3c_1 + 2c_2 = 1$

**정리 (Simplifying)**:
$c_1 + c_2 = 0$
$3c_1 + 2c_2 = 1$


$c_1$, $c_2$를 구해서 일반해를 완성하기 위해 **초기 조건을 사용**

결론적으로:$c_1 = 1$, $c_2 = -1$

$t_n = 1 \cdot (3^n) - 1 \cdot (2^n) = 3^n - 2^n$


다른 초기 조건 사용 시<br>
$t_0 = 1,\quad t_1 = 2$<br>
$t_0 = c_1 3^0 + c_2 2^0 = 1$<br>
$t_1 = c_1 3^1 + c_2 2^1 = 2$<br>
$c_1 + c_2 = 1$<br>
$3c_1 + 2c_2 = 2$<br>
$c_1 = 0,\quad c_2 = 1$<br>

$t_n = 0 \cdot (3^n) + 1 \cdot (2^n) = 2^n$



**[ 특성 방정식을 이용한 재귀식 풀이 – 예제 2 ]**

|단계|내용|
|:---:|---|
|예제 재귀식|$t_n - t_{n-1} - t_{n-2} = 0,\quad \text{for } n > 1,\quad t_0 = 0,\ t_1 = 1$|
|특성 방정식 도출|$r^2 - r - 1 = 0$|
|특성 방정식 해 구하기|$r = \frac{1 + \sqrt{5}}{2}, \quad r = \frac{1 - \sqrt{5}}{2}$
|일반해 구성 (Theorem B.1에 따라)|$t_n = c_1 \left( \frac{1 + \sqrt{5}}{2} \right)^n + c_2 \left( \frac{1 - \sqrt{5}}{2} \right)^n$|
|상수 \(c_1, c_2\) 초기 조건으로 결정|초기 조건: $t_0 = 0$<br>
$c_1 \cdot \left( \frac{1 + \sqrt{5}}{2} \right)^0 + c_2 \cdot \left( \frac{1 - \sqrt{5}}{2} \right)^0 = 1 \cdot c_1 + 1 \cdot c_2 = 0$ <br> $\Rightarrow c_1 + c_2 = 0$<br>$t_1 = 1$<br>$c_1 \cdot \left( \frac{1 + \sqrt{5}}{2} \right) + c_2 \cdot \left( \frac{1 - \sqrt{5}}{2} \right) = 1$|
|식 정리 및 상수 결정|$\left( \frac{1 + \sqrt{5}}{2} \right) c_1 + \left( \frac{1 - \sqrt{5}}{2} \right) c_2 = 1$<br>$c_2 = -c_1$ 를 대입하면<br>$\left( \frac{1 + \sqrt{5}}{2} \right) c_1 - \left( \frac{1 - \sqrt{5}}{2} \right) c_1 = 1$<br> $\Rightarrow \left( \frac{\sqrt{5}}{1} \right) c_1 = 1$<br>$\Rightarrow c_1 = \frac{1}{\sqrt{5}},\quad c_2 = -\frac{1}{\sqrt{5}}$|
|최종 일반해 (Final General Solution)|$t_n = \frac{1}{\sqrt{5}} \left( \left( \frac{1 + \sqrt{5}}{2} \right)^n - \left( \frac{1 - \sqrt{5}}{2} \right)^n \right)$<br>이 식은 피보나치 수열의 일반항과 동일|


<br>
<br>

## Multiplicity (중복도)

**[ 정의 ]**<br>
> 특성 방정식에서 어떤 근이 몇 번 중복되는지를 표현한 것<br>
$(r - 1)(r - 2)^3 = 0$: $r = 2$가 세 번 중복되므로 중복도는 3



**[ 예제1 ]** 

중복도를 가진 특성 방정식을 사용한 점화식 풀이

|단계|내용|
|:---:|---|
|특성 방정식 도출하기|점화식: $t_n - 7t_{n-1} + 15t_{n-2} - 9t_{n-3} = 0 \quad (n > 2)$<br>$t_0 = 0, \quad t_1 = 1, \quad t_2 = 2$<ㅠ특성 방정식: $r^3 - 7r^2 + 15r - 9 = 0$|
|특성 방정식 풀기|$r^3 - 7r^2 + 15r - 9 = (r - 1)(r - 3)^2 = 0$<br>중복도: $r = 1$(단일근), $r = 3$(중복도 2의 중근)<br>해의 형태: $t_n = c_1 \cdot 1^n + c_2 \cdot 3^n + c_3 \cdot n \cdot 3^n$|
|정리 B.1에 따라 일반해 구하기|$t_n = c_1 \cdot 1^n + c_2 \cdot 3^n + c_3 \cdot n \cdot 3^n$|
|초기 조건으로 상수 $c_1, c_2, c_3$구하기|초기 조건:$t_0 = 0 = c_1 \cdot 1^0 + c_2 \cdot 3^0 + c_3 \cdot (0) \cdot (3^0)$<br>$t_1 = 1 = c_1 \cdot 1^1 + c_2 \cdot 3^1 + c_3 \cdot (1) \cdot (3^1)$<br>$t_2 = 2 = c_1 \cdot 1^2 + c_2 \cdot 3^2 + c_3 \cdot (2) \cdot (3^2)$|
|식 정리|$c_1 + c_2 = 0$<br>$c_1 + 3c_2 + 3c_3 = 1$<br>$c_1 + 9c_2 + 18c_3 = 2$|
|해|$c_1 = -1, \quad c_2 = 1, \quad c_3 = -\frac{1}{3}$|
|최종 일반해|$t_n = (-1)(1^n) + (1)(3^n) + \left(-\frac{1}{3}\right)(n \cdot 3^n)$<br>$= -1 + 3^n - n \cdot 3^n \cdot \frac{1}{3} = -1 + 3^n - n \cdot 3^{n-1}$


**[ 예제2: 중복도를 가진 특성 방정식을 사용한 점화식 풀이 ]**

|단계|내용|
|:---:|---|
|점화식|$t_n - 5t_{n-1} + 7t_{n-2} - 3t_{n-3} = 0 \quad \text{for } n > 2$<br>$t_0 = 1, \quad t_1 = 2, \quad t_2 = 3$|
|특성 방정식 도출하기|$t_n - 5t_{n-1} + 7t_{n-2} - 3t_{n-3} = 0$<br>$\Rightarrow r^3 - 5r^2 + 7r - 3 = 0$|
|특성 방정식 풀기|$r^3 - 5r^2 + 7r - 3 = (r - 3)(r - 1)^2 = 0$<br>중복도: $r = 3$(단일근), $r = 1$(중복도 2의 중근)|
|정리 B.1에 따라 일반해 구하기|$t_n = c_1 \cdot 3^n + c_2 \cdot 1^n + c_3 \cdot n \cdot 1^n$|
|초기 조건으로 상수 $c_1, c_2, c_3$ 구하기|초기 조건: $t_0 = 1 = c_1 \cdot 3^0 + c_2 \cdot 1^0 + c_3 \cdot 0 \cdot 1^0$<br>$t_1 = 2 = c_1 \cdot 3^1 + c_2 \cdot 1^1 + c_3 \cdot 1 \cdot 1^1$<br>$t_2 = 3 = c_1 \cdot 3^2 + c_2 \cdot 1^2 + c_3 \cdot 2 \cdot 1^2$|
|위 식 정리|$c_1 + c_2 = 1$<br>$3c_1 + c_2 + c_3 = 2$<br>$9c_1 + c_2 + 2c_3 = 3$|
|해|$c_1 = 0, \quad c_2 = 1, \quad c_3 = 1$|
|최종 일반해|$t_n = 0 \cdot 3^n + 1 \cdot 1^n + 1 \cdot n \cdot 1^n = 1 + n$|







## 비동차 선형 점화식 예제


\[
t_n - 3t_{n-1} = 4^n (8n + 7) \quad \Rightarrow \quad k = 1, \, b = 4, \, p(n) = 8n + 7
\]

---

**[ 예제 1 ]**

$t_n - 3t_{n-1} = 4^n \quad \Rightarrow \quad k = 1, \, b = 4, \, p(n) = 1$

$t_n - 3t_{n-1} = 4^n \quad (n > 1), \quad t_0 = 0, \quad t_1 = 4$

- 점화식에서 $n$을 $n - 1$로 치환: $t_{n-1} - 3t_{n-2} = 4^{n-1}$

- 식을 4로 나눔: $\frac{t_n}{4} - \frac{3t_{n-1}}{4} = 4^{n-1}$

---

### ● 비동차 점화식 예제 1 풀이 (계속)

- 다음 두 식을 빼서 \( 4^{n-1} \) 항 제거:

\[
\frac{t_n}{4} - \frac{7t_{n-1}}{4} + 3t_{n-2} = 0
\]

- 동차 점화식으로 만들기 위해 4를 곱함:

\[
t_n - 7t_{n-1} + 12t_{n-2} = 0
\]

- 특성 방정식:

\[
t_n = r^n \Rightarrow r^2 - 7r + 12 = (r - 3)(r - 4) = 0
\]

- 일반해:

\[
t_n = c_1 \cdot 3^n + c_2 \cdot 4^n
\]

---

### ● 예제 1 해의 초기 조건 적용 (\( t_0 = 0 \), \( t_1 = 4 \))

\[
t_n = 4^{n+1} - 4 \cdot 3^n
\]

---

### ● 주의 사항 (Notice)

\[
t_n = c_1 \cdot 3^n + c_2 \cdot 4^n
\]

- 파란 상자 부분 (\( c_1 \cdot 3^n \)): 동차 점화식의 특성 방정식에서 유도된 항
- 빨간 상자 부분 (\( c_2 \cdot 4^n \)): 비동차 항 \( 4^n \)에서 유도된 항
=


아래는 주어진 이미지들에 대한 원문 그대로의 한국어 번역입니다:

---



### ● 다항식 \( p(n) \)의 차수

- 다항식 \( p(n) \)의 차수는 \( n \)의 최고차항이다.

| Polynomial \( p(n) \)           | Degree |
|-------------------------------|--------|
| \( 3n^2 + 4n - 2 \)            | 2      |
| \( 5n + 7 \)                   | 1      |
| \( 8 \)                        | 0      |

---

### ● 비동차 점화식 예제 2 풀이

\[
t_n - 3t_{n-1} = 4^n (2n + 1) \quad \text{for } n > 1
\]
\[
t_0 = 0, \quad t_1 = 12
\]

- 동차식에서 유도한 특성 방정식:

\[
t_n - 3t_{n-1} = 0 \quad \Rightarrow \quad r^1 - 3 = 0
\]

- 비동차 항으로부터 얻은 항:

\[
(r - b)^{d+1} = (r - 4)^{1+1} = (r - 4)^2
\]

---

### ● 예제 2 계속

- 위 항들로부터 특성 방정식을 구성:

\[
(r - 3)(r - 4)^2 = 0
\]

- 이 방정식을 풀면 \( r = 3 \), \( r = 4 \) (중복도 2)

- 일반해:

\[
t_n = c_1 3^n + c_2 4^n + c_3 n 4^n
\]

- 그러나 주어진 초기 조건은 2개뿐:

\[
t_0 = 0, \quad t_1 = 12
\]

- \( t_2 \)는 점화식을 사용하여 계산:

\[
t_2 - 3t_1 = 4^2(2 \cdot 2 + 1) \quad \Rightarrow \quad t_2 = 116
\]

---

### ● 예제 2 계속: 일반해 구하기

초기 조건 \( t_0 = 0 \), \( t_1 = 12 \), \( t_2 = 116 \) 를 사용하여 일반해를 구하면:

\[
t_n = 20 \cdot 3^n - 20 \cdot 4^n + 8n \cdot 4^n
\]



다음은 이미지에 포함된 **비동차 선형 점화식 예제 3번, 4번**에 대한 한국어 번역입니다:

---

## ● 비동차 선형 점화식 예제 3 풀이

\[
t_n - t_{n-1} = n - 1 \quad (n > 0), \quad t_0 = 0
\]

- 동차식에서 유도한 특성 방정식:

\[
t_n - t_{n-1} = 0 \quad \Rightarrow \quad r^1 - 1 = 0
\]

- 비동차 항에서 유도된 항:

\[
(r - 1)^{1+1}
\]

> 오른쪽 항 \( n - 1 = 1^n(n^1 - 1) \) 로부터 \( b = 1, d = 1 \)

---

## ● 예제 3 계속

- 두 항을 곱하여 얻는 특성 방정식:

\[
(r - 1)(r - 1)^2 = (r - 1)^3
\]

- \( r = 1 \)의 중복도 3 해를 갖는 방정식

- 정리 B.2에 따라 일반해는:

\[
t_n = c_1 \cdot 1^n + c_2 n \cdot 1^n + c_3 n^2 \cdot 1^n = c_1 + c_2 n + c_3 n^2
\]

- 두 개의 추가 초기 조건 계산:

\[
t_1 = t_0 + 1 - 1 = 0 + 0 = 0
\]
\[
t_2 = t_1 + 2 - 1 = 0 + 1 = 1
\]

---

## ● 예제 3 일반해 구하기

초기 조건을 사용하여 일반해 완성:

\[
t_n = \frac{n(n-1)}{2}
\]

---

## ● 비동차 선형 점화식 예제 4 풀이

\[
t_n - 2t_{n-1} = n + 2^n \quad (n > 1), \quad t_1 = 0
\]

- 동차식에서 유도한 특성 방정식:

\[
t_n - 2t_{n-1} = 0 \quad \Rightarrow \quad r^1 - 2 = 0
\]

- 비동차 항에서 유도된 항:

\[
(r - 1)^{1+1}, \quad (r - 2)^{0+1}
\]

→ 항 분석:
- \( n = (1^n) n^1 \Rightarrow b = 1, d = 1 \)
- \( 2^n = (2^n) n^0 \Rightarrow b = 2, d = 0 \)

---

## ● 예제 4 계속: 정리 B.3을 통한 특성 방정식 도출

- 동차 항: \( r^1 - 2 = 0 \)
- 비동차 항: \( (r - 1)^2 \), \( (r - 2)^1 \)

결합하여:

\[
(r - 2)(r - 1)^2(r - 2) = (r - 2)^2(r - 1)^2
\]




## 변수 치환을 이용한 점화식 풀이 

**[ 예제 1 ]**

\[
T(n) = T\left(\frac{n}{2}\right) + 1 \quad \text{(단, } n > 1, \text{ n은 2의 거듭제곱)}, \quad T(1) = 1
\]

- 아래와 같이 점화식을 변형:

\[
n = 2^k \Rightarrow k = \log_2 n
\]

- 점화식에 \( n = 2^k \)를 대입:

\[
T(2^k) = T\left(\frac{2^k}{2}\right) + 1 = T(2^{k-1}) + 1
\]


- \( t_k = T(2^k) \)로 두면,

\[
t_k = t_{k-1} + 1
\]

- 정리 B.3에 따라 해는:

\[
t_k = c_1 + c_2 k
\]

---

- 원래 점화식의 일반해를 얻기 위해:

① \( T(2^k) = t_k = c_1 + c_2 k \)  
② \( k = \log_2 n \) 대입

\[
T(n) = c_1 + c_2 \log_2 n
\]

- 초기 조건 \( T(1) = 1 \)을 이용하면:

\[
T(n) = 1 + \log_2 n
\]



**[ 예제 2 ]**

\[
T(n) = 7T\left(\frac{n}{2}\right) + 18\left(\frac{n}{2}\right)^2, \quad T(1) = 0
\]

- \( n = 2^k \Rightarrow k = \log_2 n \)

- \( n = 2^k \)를 대입하면:

\[
T(2^k) = 7T(2^{k-1}) + 18(2^{k-1})^2
\]


\[
t_k = 7t_{k-1} + 18(2^{k-1})^2 = 7t_{k-1} + 18 \cdot 4^{k-1}
\]

\[
= 7t_{k-1} + 4^k \cdot \left(\frac{18}{4}\right)
\]

- 정리 B.3에 따라:

\[
t_k = c_1 \cdot 7^k + c_2 \cdot 4^k
\]


원래 점화식의 일반해 구하기

- \( T(2^k) = t_k = c_1 \cdot 7^k + c_2 \cdot 4^k \)

- \( k = \log_2 n \) 대입:

\[
T(n) = c_1 \cdot n^{\log_2 7} + c_2 \cdot n^2
\]

- 초기 조건 \( T(1) = 0 \)을 대입:

\[
T(n) = 6n^{\log_2 7} - 6n^2 \approx 6n^{2.81} - 6n^2
\]



## Substitution(대입법)을 이용한 재귀식 풀이 

**[ 예제 1 ]**
\[
t_n = t_{n-1} + n \quad \text{(for } n > 1) \\
t_1 = 1
\]

- 귀납법과 반대처럼, \(n\)부터 1까지 거꾸로 시작  
\[
\begin{align*}
t_n &= t_{n-1} + n \\
t_{n-1} &= t_{n-2} + n - 1 \\
t_{n-2} &= t_{n-3} + n - 2 \\
&\vdots \\
t_2 &= t_1 + 2 \\
t_1 &= 1
\end{align*}
\]

*  
- 각 등식을 대입해서 \(t_n\)을 구함:

\[
\begin{align*}
t_n &= t_{n-1} + n \\
&= t_{n-2} + (n - 1) + n \\
&= t_{n-3} + (n - 2) + (n - 1) + n \\
&\vdots \\
&= t_1 + 2 + \cdots + (n - 2) + (n - 1) + n \\
&= 1 + 2 + \cdots + (n - 1) + n \\
&= \sum_{i=1}^n i = \frac{n(n+1)}{2}
\end{align*}
\]


**[ 예제 2 ]**

\[
t_n = t_{n-1} + \frac{2}{n} \quad (n > 1), \quad t_1 = 0
\]

- 귀납법과 반대로 \(n\)에서 1로 진행:

\[
\begin{align*}
t_n &= t_{n-1} + \frac{2}{n} \\
t_{n-1} &= t_{n-2} + \frac{2}{n - 1} \\
t_{n-2} &= t_{n-3} + \frac{2}{n - 2} \\
&\vdots \\
t_2 &= t_1 + \frac{2}{2} \\
t_1 &= 0
\end{align*}
\]


- 각 등식을 대입해서 \(t_n\) 구하기:

\[
\begin{align*}
t_n &= t_{n-1} + \frac{2}{n} \\
&= t_{n-2} + \frac{2}{n - 1} + \frac{2}{n} \\
&= t_{n-3} + \frac{2}{n - 2} + \frac{2}{n - 1} + \frac{2}{n} \\
&\vdots \\
&= t_1 + \frac{2}{2} + \cdots + \frac{2}{n - 2} + \frac{2}{n - 1} + \frac{2}{n} \\
&= 0 + \cdots + \frac{2}{n - 2} + \frac{2}{n - 1} + \frac{2}{n} \\
&= 2 \sum_{i=2}^n \frac{1}{i} \approx 2 \ln n
\end{align*}
\]



## 시간 복잡도
n이 어떤 양의 상수 b의 거듭제곱일 때의 결과를 일반적인 n으로 확장하기

**• 네 가지 시간 복잡도 함수**

1. (a) **엄격히 증가하는 함수 (Strictly Increasing)**  
   - 항상 증가

2. (b) **비감소 함수 (Nondecreasing)**  
   - 절대 감소하지 않음

3. (c) **비비감소 함수가 아님 (Not Nondecreasing)**  
   - 오르내림 반복

4. (d) **궁극적으로 비감소하는 함수 (Eventually Nondecreasing)**  
   - 일정 시점 이후로는 증가 또는 유지


**• 증가하는 시간 복잡도**

- **정의**  
  복잡도 함수 f(n)이 항상 n이 증가함에 따라 커지면 이를 **엄격히 증가함(strictly increasing)** 이라고 한다.  
  즉, n₁ > n₂ 이면,  
  → f(n₁) > f(n₂)

- **예시 함수들**  
  - log₂n, n, n log n, n², 2ⁿ 등 (단, n ≥ 0일 때)



**• 비감소 시간 복잡도**

- **정의**  
  복잡도 함수 f(n)이 n이 증가함에 따라 절대 감소하지 않으면, 이를 **비감소함(nondecreasing)** 이라고 한다.  
  즉, n₁ > n₂ 이면,  
  → f(n₁) ≥ f(n₂)

- **설명**  
  대부분의 시간 복잡도 함수는 비감소 함수이다.



**• '비비감소가 아님(Not Nondecreasing)'**

- 예시: n이 2의 거듭제곱일 때의 f(n)
  - 예: 2³ = 8, 2⁴ = 16 사이에서 결론 불가
- ❗ 하지만 만약 f(n)이 비감소 함수라면  
  → f(8) ≤ n ≤ f(16) 이라는 범위가 성립  
  (8 ≤ n ≤ 16 구간에서)

- **결론:**  
  비감소가 아닌 함수는 일반적인 시간 복잡도를 **판단할 수 없음**


'Eventually Not Nondecreasing’ (결국 증가하지 않음이 아닌 함수)

**정의**  
복잡도 함수 \( f(n) \)은 어떤 시점 이후로 절대 작아지지 않으면 **결국 증가하지 않음(eventually nondecreasing)**이라 부른다. 즉, 어떤 \( N \)이 존재하여  
\( n_1 > n_2 > N \)일 때는 항상  
\[
f(n_1) \geq f(n_2)
\]  
를 만족한다.

(아래 그래프는 일정 시점 \( N \) 이후로는 증가하거나 유지되는 함수의 예)

---

### 📌 'Eventually Not Nondecreasing' 조건을 통해 \( n \)이 \( b \)의 거듭제곱일 때 일반 \( n \)으로 확장

**정의**  
복잡도 함수 \( f(n) \)이 **결국 증가하지 않음(eventually nondecreasing)**이고  
\[
f(2n) \in \Theta(f(n))
\]  
을 만족하면 **부드러운 함수(smooth function)**라 부른다.

**Smooth 함수의 예시**  
- \( \lg n, n, n \lg n, n^k \)  
- \( \lg(2n) = \lg 2 + \lg n \in \theta(\lg n) \)

---

### 📌 정리

정수 \( b \geq 2 \)일 때,  
- \( f(n) \): **smooth 복잡도 함수**  
- \( T(n) \): **eventually nondecreasing 복잡도 함수**

다음이 성립한다면  
\[
T(n) \in \Theta(f(n)) \quad \text{(단, \( n \)이 \( b \)의 거듭제곱일 때)}
\]

결론적으로  
\[
T(n) \in \Theta(f(n))
\]  
도 성립한다.  
※ 위 정리는 \(\Theta\)뿐만 아니라 \(O\), \(\Omega\), 소문자 \(o\) 표기에도 동일하게 적용된다.



### 📌 예제

$T(n) = T\left( \left\lfloor \frac{n}{2} \right\rfloor \right) + 1 \quad \text{(단, \( n > 1 \))}, \quad T(1) = 1$

**시간 복잡도**  
$T(n) = \lg n + 1 \in \Theta(\lg n)$ ($n$이 2의 거듭제곱일 때)$

- 2의 거듭제곱 사이의 값들에 대한 결론은 없음 ❗️

**귀납법으로 $T(n)$이 eventually nondecreasing임을 증명**

$n \geq 2$에 대해, $ 1 \leq k \leq n$이면  $T(k) \leq T(n)$


- **귀납 기본 단계**  
$T(1) = 1$
$T(2) = T\left(\left\lfloor \frac{2}{2} \right\rfloor\right) + 1 = T(1) + 1 = 2$ 
$T(1) \leq T(2)$

**귀납 가정**  
모든 $m \leq n$에 대해, $k < m$이면 $T(k) \leq T(m)$

**귀납 단계**  
가정에 따라 $k < n$이면  $T(k) \leq T(n)$

**귀납 단계 (계속)**

- 보여야 할 것:  
$T(n) \leq T(n+1)$

- 다음의 참인 명제 사용:  
$\left\lfloor \frac{n}{2} \right\rfloor \leq \left\lfloor \frac{n+1}{2} \right\rfloor \leq n$

- 귀납 가정에 따라:  
$T\left(\left\lfloor \frac{n}{2} \right\rfloor\right) \leq T\left(\left\lfloor \frac{n+1}{2} \right\rfloor\right)$

- 결론적으로:  
$T(n) = T\left(\left\lfloor \frac{n}{2} \right\rfloor\right) + 1 \leq T\left(\left\lfloor \frac{n+1}{2} \right\rfloor\right) + 1 = T(n+1)$





