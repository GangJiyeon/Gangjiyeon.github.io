---
title: "[알고리즘] 분할정복과 알고리즘"
categories:
  - ds_ai
tags: [알고리즘]
use_math: true
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---
<br>
<br>
<br>


# 분할 정복(Divide and Conquer)과 기본 알고리즘

## Divide and Conquer 개념 및 Top-Down 방식

**[ 분할정복법 ]**
> `분할 정복법`은 문제를 더 작은 하위 문제로 나누고, 각 하위 문제를 독립적으로 해결한 뒤, 그 결과를 합쳐 원래 문제의 해답을 구하는 알고리즘 설계 기법<br>
• `Divide (분할)`: 문제를 더 작은 하위 문제로 나눔<br>
• `Conquer (정복)`: 하위 문제를 재귀적으로 해결<br>
• `Combine (결합)`: 하위 문제의 해를 이용해 전체 문제의 해를 구성


**[ top-down 방식 ]**<br>
> • 하나의 문제 인스턴스를 두 개 이상의 더 작은 인스턴스로 나눔<br>
• 더 작은 인스턴스들의 해답을 쉽게 구할 수 있으면, 이 해답을 결합하여 원래 문제의 해답을 얻을 수 있음

`참고` bottop-up 방식<br>
• 가장 작은 문제부터 시작해서 차례대로 큰 문제를 해결<br>
• 작은 문제의 결과를 저장하고 재사용 (동적 계획법에서 자주 사용)<br>
• 반복문을 이용해 구현됨<br>
• 예: 동적 계획법(Dynamic Programming), 피보나치 수열의 DP 구현


<br>

## Binary Search (이진 탐색) - 재귀적

**[ Binary Search 문제 ]**<br>
**`정의`**  
> 정렬된(비감소 순서) 배열에서 키 `x`의 위치를 찾는 문제

**`방법`** 
> 배열의 가운데 항목과 `x`를 비교함<br>
• 같으면 알고리즘 종료<br>
• 다르면 배열을 두 부분으로 나눔: 가운데 항목의 왼쪽 부분, 가운데 항목의 오른쪽 부분

**`핵심 단계`**  <br>
• 배열을 절반 크기의 두 부분으로 나눈다: `x`가 가운데보다 작으면 왼쪽 부분, 크면 오른쪽 부분 선택 <br>
• 해당 부분에서 `x`가 있는지 확인, 크기가 충분히 작지 않으면 재귀 호출 사용  <br>
• 해당 부분에서의 결과가 전체 배열에 대한 해답이 됨

**`특이사항`**  
> 작은 인스턴스로 나누지만, 그들의 **출력을 결합하지 않음**

<br>

**[ 이진 탐색 알고리즘 설계 ]**<br>
**`기본 설계 원칙`**  <br>
• 더 작은 인스턴스의 해로부터 원래 문제의 해를 구하는 방법 개발  <br>
• 더 작은 인스턴스가 도달하게 될 종료 조건 설정  <br>
• 종료 조건에 해당하는 경우의 해 결정

**`프로그래밍 시 유의사항`**<br>
• 이 자료에서는 재귀 호출 중 값이 변할 수 있는 변수들만 재귀 루틴의 매개변수로 사용<br>
• **꼬리 재귀(tail-recursion)** 사용 요구: 재귀 호출 이후 연산 없음, 꼬리재귀를 반복문 기반 알고리즘으로 전환 시 메모리 효율성 ↑

**`주의`**<br>
• 재귀 루틴의 경우, **스택에 쌓이는 activation record 수는 재귀 호출이 도달한 깊이에 따라 결정**

<br>

**`예시`**

> 정렬된 배열에서 `x = 18`을 찾는 과정:

```
[10 12 13 14 18 20 25 27 30 35 40 45 47]

- 25와 비교 → x < 25 → 왼쪽 선택
- 13과 비교 → x > 13 → 오른쪽 선택
- 18과 비교 → x = 18 → 탐색 성공
```

<br>

**`의사코드`**

```c
/*
problem: 크기가 n인 정렬된 배열에서 x 찾기
input: 정수 n, 정렬된 배열 S[1...n], 탐색 키 x 
output: x가 있는 위치(없으면 0 반환)
*/
index location(index low, index high)
{
    index mid;
    if (low > high)
        return 0;
    else {
        mid = ⌊(low + high) / 2⌋;
        if (x == S[mid])
            return mid;
        else if (x < S[mid])
            return location(low, mid - 1);
        else
            return location(mid + 1, high);
    }
}
```


**[ 최악의 시간 복잡도 분석 ]**<br>
$W(n) = W(n/2) + 1$<br>
$W(n/2)$: 재귀호출에서의 비교<br>
$1$: top level에서의 비교


• $t_n = \log_2 n + 1 \quad$ 몇 개의 값을 통해 확인<br>
$t_2 = t_{2/2} + 1 = t_1 + 1 = 1 + 1 = 2$<br>
$t_4 = t_{4/2} + 1 = t_2 + 1 = 2 + 1 = 3$<br>
$t_8 = t_{8/2} + 1 = t_4 + 1 = 3 + 1 = 4$<br>
$t_{16} = t_{16/2} + 1 = t_8 + 1 = 4 + 1 = 5$


`귀납 기초 (Induction base)`: $t_1 = 1 = \log 1 + 1$

`귀납 단계 (Induction step when $2n$)`<br> 
• (재귀는 2의 거듭제곱에 대해서만 정의됨) <br>  
• $t_{2n} = \log 2n + 1$

`증명 과정`<br>
$t_{2n} = t_{2n/2} + 1 = t_n + 1$<br>
$= \log n + 1 + 1$<br>
$= \log n + \log 2 + 1$<br>
$= \log(2n) + 1$




<br>


## Merge Sort (합병 정렬)

**[ 예시 ]**


**[ 의사코드: not in-place ]**

`예시 1 - mergesort`

```c
// 문제: n개의 키를 비감소(non-decreasing) 순서로 정렬하라
// 입력: 양의 정수 n, 인덱스 1부터 n까지의 키 배열 S
// 출력: 비감소 순서로 정렬된 키들을 포함하는 배열 S
void mergesort (int n, keytype S[]) {
    if (n > 1) {
        const int h = ⌊n/2⌋, m = n - h;
        keytype U[1..h], V[1..m];

        // S를 절반씩 나누어 각각 U와 V로 복사
        copy S[1] through S[h] to U[1] through U[h];
        copy S[h+1] through S[n] to V[1] through V[m];

        // 각각 재귀적으로 정렬
        mergesort(h, U);
        mergesort(m, V);

        // 정렬된 두 배열을 병합
        merge(h, m, U, V, S);
    }
}
```


`예시 2 - merge`

```c
// 문제: 정렬된 두 배열을 하나의 정렬된 배열로 병합하라
// 입력: 양의 정수 h, m
//      인덱스 1부터 h까지의 정렬된 배열 U
//      인덱스 1부터 m까지의 정렬된 배열 V
// 출력: 인덱스 1부터 h + m까지의 정렬된 배열 S, U와 V의 모든 원소 포함

/*
inplace sort가 아니다
→ 정렬 과정에서 새로운 배열(U, V)을 계속 만들어서 공간을 추가로 사용함
→ 특히, 재귀 호출 중마다 메모리가 쌓이므로 활성 스택도 증가
*/
void merge (int h, int m, const keytype U[], const keytype V[], keytype S[]) {
    index i, j, k;
    i = 1; j = 1; k = 1;

    while (i <= h && j <= m) {
        if (U[i] < V[j]) {
            S[k] = U[i];
            i++;
        } else {
            S[k] = V[j];
            j++;
        }
        k++;
    }

    // 남은 요소 복사
    if (i > h)
        copy V[j] through V[m] to S[k] through S[h+m];
    else
        copy U[i] through U[h] to S[k] through S[h+m];
}
```



**[ 의사코드: in-place ]**

`예시 1 - Mergesort 2 (in-place sort)`

```c
/*
문제: n개의 키를 비감소(non-decreasing) 순서로 정렬하라
입력: 양의 정수 n, 인덱스 1부터 n까지의 키 배열 S
출력: 정렬된 상태의 배열 S
*/

void mergesort2(index low, index high) {
    index mid;
    if (low < high) {
        mid = ⌊(low + high)/2⌋;
        mergesort2(low, mid);
        mergesort2(mid + 1, high);
        merge2(low, mid, high);
    }
}
```

`예시 2 - Merge 2`

```c
// U는 정렬을 위한 임시 배열 (in-place라 하더라도 공간은 일부 사용)
// 최종적으로 U의 내용을 다시 S로 복사 → 원본 배열이 정렬됨
/*
문제: Mergesort 2에서 생성된 두 정렬된 부분 배열을 병합하라
입력: 인덱스 low, mid, high
     배열 S[low..high] (두 부분 [low..mid], [mid+1..high]는 각각 정렬된 상태)
출력: 전체 범위 S[low..high]가 정렬된 상태로 병합됨
*/

void merge2(index low, index mid, index high) {
    index i, j, k;
    keytype U[low..high]; // 병합을 위한 임시 배열

    i = low; j = mid + 1; k = low;

    while (i <= mid && j <= high) {
        if (S[i] < S[j]) {
            U[k] = S[i];
            i++;
        } else {
            U[k] = S[j];
            j++;
        }
        k++;
    }

    if (i > mid) {
        move S[j] through S[high] to U[k] through U[high];
    } else {
        move S[i] through S[mid] to U[k] through U[high];
    }

    move U[low] through U[high] to S[low] through S[high];
}

```


## Quick Sort (퀵 정렬)

## 각 알고리즘의 재귀적 구조 및 시간 복잡도 분석


<br>
<br>
<br>

# 고급 알고리즘과 최적화
Strassen의 행렬 곱셈 알고리즘

큰 정수 곱셈 및 개선된 알고리즘

Threshold 개념 (알고리즘 전환 시점)


<br>
<br>
<br>

# 재귀 관계식의 수학적 해석
수학적 귀납법을 통한 해법

Factorial 및 단순한 예제 풀이

시간 복잡도 분석의 기초로서의 재귀식


<br>
<br>
<br>

# 재귀식 풀이 고급 기법

특성 방정식을 이용한 해법 (동차 / 비동차)

일반해 도출, 상수 결정, 다항식 포함 사례

변수 치환 기법과 대입법(Substitution)


<br>
<br>
<br>

# 점근적 분석 및 마스터 정리


시간 복잡도 함수 분석 (lg n, n log n 등)

일반 n에 대한 확장 기법

Master Theorem 및 확장 사례

