---
title: "[ì•Œê³ ë¦¬ì¦˜] íƒìš• ì•Œê³ ë¦¬ì¦˜ê³¼ íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì ìš©"
excerpt: "í¬ë£¨ìŠ¤ì¹¼/í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜, ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜, "
categories:
  - ds_ai
tags: [ì•Œê³ ë¦¬ì¦˜]
use_math: true
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---


<br>
<br>

# Greedy Algorithm
## Greedy ì•Œê³ ë¦¬ì¦˜ì˜ ê°œë…
**[ ê°œë… - Local Optimization Approach ]**  
> ì§€ì—½ì ì¸ ë°©ë²•ì„ ê°€ê³  ìµœì í™”ëœ(ë¼ê³  ë¯¿ëŠ”)ê°’ì„ ì„ íƒí•˜ëŠ” ë°©ë²•
> â€¢ ì¼ë ¨ì˜ ì„ íƒë“¤ì„ ìˆ˜í–‰í•˜ë©°, ê° ì„ íƒì€ ê·¸ ìˆœê°„ ê°€ì¥ ì¢‹ì•„ ë³´ì´ëŠ” ê²ƒì„ ì„ íƒí•¨  
> â€¢ ê° ì„ íƒì€ **êµ­ì†Œì ìœ¼ë¡œ ìµœì **ì¼ ìˆ˜ ìˆìœ¼ë‚˜, **ì „ì—­ì ìœ¼ë¡œ ìµœì **ì€ ì•„ë‹ ìˆ˜ ìˆìŒ

<br>

**[ ì˜ˆì‹œ: Exchanges Greedy Algorithm ]**

```c
while (there are more coins and the instance is not solved){
    grab the largest remaining coin;            // selection procedure
    if (adding the coin makes the change exceed the amount owed)  // feasibility check
        reject the coin;
    else
        add the coin to the change;
    if (the total value of the change equals the amount owed)     // solution check
        the instance is solved;
}
```

|ìµœì ì˜ ë°©ë²•|ìµœì ì´ ì•„ë‹Œ ë°©ë²•|
|---|---|
|||


```c
F = âˆ…               // Initialize set of
                    // edges to empty
while (the instance is not solved){
    select an edge according to some locally optimal consideration;   // selection procedure
    if (adding the edge to F does not create a cycle)                 // feasibility check
        add it;
    if (T = (V, F) is a spanning tree)                                // solution check
        the instance is solved;
}
```

<br>
<br>


# íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì ìš© ì˜ˆì‹œ
> ì´ ê¸€ì—ì„œëŠ” `í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜`, `í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜`, `ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜` ì˜ íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì‚¬ìš© ì˜ˆì‹œë¥¼ ë‹¤ë£¬ë‹¤!


## `ì°¸ê³ ` Minimum Spanning Tree(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
**[ Undirected Graph ]**<br>
> ë¬´ë°©í–¥ ê·¸ë˜í”„ $G$ëŠ” ìœ í•œí•œ ì •ì  ì§‘í•© $V(vertex)$ê³¼, ê°„ì„  ì§‘í•© $E(edge)$ë¡œ êµ¬ì„±<br>
â€¢ ì •ì : $G$ì˜ ì •ì ì´ë¼ ë¶ˆë¦¼<br>
â€¢ ê°„ì„ : ì •ì ë“¤ì˜ ìŒë“¤ë¡œ êµ¬ì„±ëœ ì§‘í•©, $G$ì˜ ê°„ì„ ì´ë¼ê³  ë¶€ë¦„<br> 
â€¢ í‘œê¸°: $G = (V, E)$

**`ì˜ˆì‹œ`**

|ì´ë¯¸ì§€|ì„¤ëª…|
|:---:|---|
|![graph1](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png)|â€¢ $|E| = 7$, $|V| = 5$<br>â€¢ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ëœ ë…¸ë“œ: ì´ì›ƒ<vr>â€¢ ê·¸ë˜í”„ì—ëŠ” ìˆœí™˜ì€ ìˆì–´ì„œ íŠ¸ë¦¬ëŠ” ì•„ë‹˜<br>$V = {v_1, V_2, V_3, V_4, V_5}$<br>$E = {(V_1, V_2), (V_1, V_3), (V_2, V_3), (V_2, V_4), (V3, V_4), (V_3, V_5), (V_4, V_5)}$|

**[ Tree Structure ]**
> â€¢ ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ ì—£ì§€ë¥¼ ì œê±°í•˜ì—¬ **ìˆœí™˜ êµ¬ì¡°ë¥¼ ì—†ì• ê³ ** ì—°ê²°ì„±ì„ ìœ ì§€í•œ ì„œë¸Œê·¸ë˜í”„
> â€¢ íŠ¸ë¦¬ëŠ” **ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³ ** ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²°ëœ êµ¬ì¡°  
> â€¢ ë©”ì‹œì§€ ì „íŒŒ, ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë“±ì—ì„œ ì„ í˜¸ë¨: ë¹„ìš©ì´ ì¤„ì–´ë“¦

**`ì˜ˆì‹œ`**
![graph2&3](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_2&3.png)
â€¢ (c) ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬: weight = 15  
â€¢ (d) ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬: weight = 10


**[ Minimum Spanning Tree ]**
> ê·¸ë˜í”„ $G$ì˜ **ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³  ì—°ê²°ëœ** ë¶€ë¶„ ê·¸ë˜í”„ì´ë©° **íŠ¸ë¦¬**
> â€¢ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°–ëŠ” ì—°ê²°ëœ ë¶€ë¶„ ê·¸ë˜í”„ëŠ” ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì—¬ì•¼ í•¨
> â€¢ í•˜ì§€ë§Œ ëª¨ë“  ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê²ƒì€ ì•„ë‹˜




<br>
<br>
<br>



## Kruskal Algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜)
### Kruskal ì•Œê³ ë¦¬ì¦˜ì´ë€?
**[ ì •ì˜ ]**
> **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Minimum Spanning Tree)**ë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì¸ **Greedy Algorithm(íƒìš• ì•Œê³ ë¦¬ì¦˜)**
> â€¢ **ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ìµœì†Œí•œì˜ ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•˜ë©´ì„œ, ì „ì²´ ê°„ì„  ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œ**ê°€ ë˜ë„ë¡ êµ¬ì„±
> â€¢ Prim ì•Œê³ ë¦¬ì¦˜ê³¼ ë‹¬ë¦¬ **ê°„ì„  ì¤‘ì‹¬(edge-based)** ì•Œê³ ë¦¬ì¦˜

**[ ê¸°ë³¸ ì•„ì´ë””ì–´ ]**  
â€¢ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ ë¶€í„° í•˜ë‚˜ì”© ì„ íƒí•˜ë©´ì„œ,  
â€¢ **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡** ì£¼ì˜í•˜ë©°  
â€¢ $(|V| - 1)$ê°œì˜ ê°„ì„ ì„ ì„ íƒí•˜ë©´ ì™„ë£Œ

**[ í•µì‹¬ ë„êµ¬ ]**
â€¢ **Greedy ë°©ì‹**ìœ¼ë¡œ ê°„ì„  ì„ íƒ  
â€¢ **Union-Find (Disjoint Set)** ìë£Œêµ¬ì¡°ë¡œ ì‚¬ì´í´ íŒë‹¨

<br>

### ë™ì‘ ì˜ˆì‹œ (How it works)

**[ ì´ˆê¸° ê·¸ë˜í”„ ì£¼ì–´ì§ ]**<br>

**[ ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ ]**  <br>

```
sort â†’ (v2,v3), (v1,v2), (v3,v5), (v2,v5), (v1,v4), (v3,v4)
```

**[ ì„œë¡œì†Œ ì§‘í•© ì´ˆê¸°í™” ]**  <br>
â€¢ ì •ì  ìˆ˜ \( N \)
â€¢ ê°„ì„  ìˆ˜ \( |E| \) = 1ë¶€í„° ì‹œì‘ â†’ \( |E| = N - 1 \)ì´ ë  ë•Œê¹Œì§€

**[ ê° ë‹¨ê³„ì—ì„œ ë°˜ë³µ ]**  <br>
â€¢ ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„  ì„ íƒ  <br>
â€¢ ì‚¬ì´í´ ì—†ìœ¼ë©´ ì¶”ê°€, ì‚¬ì´í´ ìƒê¸°ë©´ ë¬´ì‹œ  

**[ ëª¨ë“  ì •ì ì´ ì—°ê²°ëœ í•˜ë‚˜ì˜ ì§‘í•©ì´ ë˜ë©´ ì™„ë£Œ ]**<br> 

ğŸ“Œ ì•„ë˜ ìš”ì•½:<br>
â€¢ ì„œë¡œì†Œ ì§‘í•©: $V = \{V_1, V_2, ..., V_5\}$ <br>
â€¢ ì˜ˆ: $\{v1\}, \{v2\}, ... \) â†’ \( \{v1, v2\}$ë¡œ ë³‘í•©ë¨

---



### ì•Œê³ ë¦¬ì¦˜ ê°œìš” (Overview)

```c
F = âˆ…;                             // ê°„ì„  ì§‘í•© ì´ˆê¸°í™”

create disjoint subsets of V,      // ê° ì •ì ë§ˆë‹¤ í•˜ë‚˜ì”© ë¶„ë¦¬ëœ ì§‘í•© ìƒì„±
one for each vertex and 
containing only that vertex;

sort the edges in E in nondecreasing order;  // ê°„ì„ ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬

while (the instance is not solved){          // í•´ê²°ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë°˜ë³µ
    select next edge;                        // ê°„ì„  ì„ íƒ (ì„ íƒ ì ˆì°¨)
    
    if (the edge connects two vertices in disjoint subsets){  // ì í•©ì„± ê²€ì‚¬
        merge the subsets;
        add the edge to F;                   // ê°„ì„ ì„ ì¶”ê°€
    }

    if (all the subsets are merged)         // ëª¨ë“  ì •ì ì´ í•˜ë‚˜ì˜ ì§‘í•©ì´ë©´
        the instance is solved;             // í•´ê²° ì™„ë£Œ
}

//ë˜ëŠ” ê°„ì„ ì˜ ìˆ˜|F| = |V| - 1ì´ ë˜ë©´ ì¢…ë£Œí•´ë„ ë¨
```


### Kruskal ì•Œê³ ë¦¬ì¦˜ ì½”ë“œ (ì˜ì‚¬ì½”ë“œ)

```cpp
void kruskal(int n, int m,
             set_of_edges E,
             set_of_edges& F)
{
    index i, j;
    set_pointer p, q;
    edge e;

    Sort the m edges in E by weight in nondecreasing order;
    F = âˆ…;
    initial(n);                     // nê°œì˜ ë¶„ë¦¬ëœ ì§‘í•© ì´ˆê¸°í™”

    while (number of edges in F is less than n - 1){
        e = edge with least weight not yet considered;
        i, j = indices of vertices connected by e;
        p = find(i);
        q = find(j);

        if (!equal(p, q)){
            merge(p, q);           // ì§‘í•© ë³‘í•©
            add e to F;
        }
    }
}
```


**[ ì‹œê°„ë³µì¡ë„ ë¶„ì„ (Analysis) ]**
> ê°„ì„  ì •ë ¬ì´ Kruskalì˜ í•µì‹¬ ì‹œê°„ ì†Œëª¨ ìš”ì†Œ  
$W(m) \in \Theta(m \log m)$

- ì—¬ê¸°ì„œ $m$ì€ ê°„ì„  ìˆ˜, $n$ì€ ì •ì  ìˆ˜  
- í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ **ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì •ë ¬ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ**ê°€ í•µì‹¬


<br>
<br>
<br>

## Prim's Algorithm(í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜)

### í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ê°œìš”
**[ ê·¸ë˜í”„ë¡œ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì§„í–‰ê³¼ì • ì•Œì•„ë³´ê¸° ]**<br>

|ë‹¨ê³„ë³„ ì´ë¯¸ì§€|ì„¤ëª…|ì§‘í•©|
|:---:|:---:|:---:|
||ìµœì†Œì‹ ì¥íŠ¸ë¦¬ ê²°ì •í•˜ê¸°|$V={v_1, v_2, v_3, v_4, v_5}$<br>$Y={}$|
||ì •ì  $v_1$ì„ ì²˜ìŒìœ¼ë¡œ ì„ íƒ||


**[ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ë¥¼ ì¸ì ‘í–‰ë ¬ë¡œ í‘œí˜„í•˜ê¸° ]**<br>

```c
int adjacency_matrix[][] = 
{
    [0][2][3][âˆ][âˆ]
    [2][0][15][2][âˆ]
    [3][15][0][0][13]
    [0][2][âˆ][âˆ][9]
    [0][0][13][9][0]
}
```


**[ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ê°œìš” ]**<br>

```c
F = âˆ…;          // Initialize set of edges to empty.
Y = {u1};       // Initialize set of vertices to contain only the first one.

while (the instance is not solved){
    select a vertex in V â€“ Y that is nearest to Y;   // selection procedure
    add the vertex to Y;
    add the edge to F;

    if (Y == V)    // solution check
        the instance is solved;
}
```



<br>
<br>

### ì˜ì‚¬ì½”ë“œ ë° ì‹¤í–‰ì˜ˆì‹œ

```c
void prim (int n,
           const number W[][],
           set_of_edges F)
{
    index i, k, vnear;
    number min;
    edge e;
    index nearest[2..n];
    number distance[2..n];

    F = âˆ…;
    for (i = 2; i <= n; i++) {
        nearest[i] = 1;                        // ëª¨ë“  ì •ì ì— ëŒ€í•´ u1ì„ ê°€ì¥ ê°€ê¹Œìš´ ì •ì ìœ¼ë¡œ ì´ˆê¸°í™”
        distance[i] = W[1][i];                 // Yì—ì„œ iê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ê°€ì¤‘ì¹˜ë¡œ ì´ˆê¸°í™”
    }

    repeat (n âˆ’ 1 times) {                    // Yì— nâˆ’1ê°œì˜ ì •ì ì„ ì¶”ê°€
        min = âˆ;
        for (i = 2; i <= n; i++) {              // ëª¨ë“  ì •ì ì— ëŒ€í•´
            if (0 â‰¤ distance[i] < min) {      // Yì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  ì¤‘ ìµœì†Œ ê±°ë¦¬ ì„ íƒ
                min = distance[i];            // ìµœì†Œê°’ ê°±ì‹ 
                vnear = i;
            }
        }

        e = edge connecting vertices indexed
            by vnear and nearest[vnear];      // vnearì™€ ê°€ì¥ ê°€ê¹Œìš´ ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°„ì„  e
        add e to F;                           // eë¥¼ Fì— ì¶”ê°€
        distance[vnear] = âˆ’1;                 // vnearë¥¼ Yì— ì¶”ê°€í–ˆìŒì„ í‘œì‹œ

        for (i = 2; i <= n; i++) {          // Yì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì ë“¤ì— ëŒ€í•´
            if (W[i][vnear] < distance[i]) {  // vnearë¥¼ ê±°ì³ê°€ëŠ” ê±°ë¦¬ê°€ ë” ì§§ë‹¤ë©´
                distance[i] = W[i][vnear];    // ê±°ë¦¬ ê°±ì‹ 
                nearest[i] = vnear;           // ê°€ì¥ ê°€ê¹Œìš´ ì •ì  ê°±ì‹ 
            }
        }
    }
}
```



### ìˆ˜í•™ì  ì¦ëª…

> í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ í•­ìƒ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ìƒì„±<br>
ì¦ëª…: ë°˜ë³µ ë£¨í”„ì˜ ê° ë‹¨ê³„ ì´í›„ ê°„ì„  ì§‘í•© Fê°€ ìœ ë§í•˜ë‹¤ëŠ” ê²ƒì„ ìˆ˜í•™ì  ê·€ë‚©ë²•ìœ¼ë¡œ ì¦ëª…


**[ ê¸°ì´ˆ ë‹¨ê³„ (Induction base) ]**<br>
> ì´ˆê¸° ìƒíƒœì¸ ê³µì§‘í•© FëŠ” ìœ ë§

**[ ê·€ë‚© ê°€ì • (Induction hypothesis) ]**<br>
> ë°˜ë³µ ë£¨í”„ì˜ ì–´ë–¤ ë‹¨ê³„ ì´í›„, í˜„ì¬ê¹Œì§€ ì„ íƒëœ ê°„ì„  ì§‘í•© Fê°€ ìœ ë§í•˜ë‹¤ê³  ê°€ì •

**[ ê·€ë‚© ë‹¨ê³„ (Induction step) ]**<br>
> â€¢ ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ì„ íƒë  ê°„ì„  eê°€ F âˆª {e}ë¥¼ ì—¬ì „íˆ ìœ ë§í•˜ê²Œ ë§Œë“¦ì„ ë³´ì—¬ì•¼ í•¨<br>
â€¢ ì„ íƒëœ ê°„ì„  eëŠ” Yì™€ V - Yë¥¼ ì—°ê²°í•˜ëŠ” ê°„ì„  ì¤‘ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ <br>
â€¢ ë”°ë¼ì„œ F âˆª {e}ëŠ” ì—¬ì „íˆ ìœ ë§í•œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ë¶€ë¶„ ì§‘í•©<br>

`ê²°ë¡ ` ë°˜ë³µ ë£¨í”„ê°€ ëë‚œ í›„ì˜ FëŠ” í•˜ë‚˜ì˜ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ê°€ ë¨