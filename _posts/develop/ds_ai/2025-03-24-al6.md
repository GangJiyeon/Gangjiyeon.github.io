---
title: "[ì•Œê³ ë¦¬ì¦˜] ìµœì†Œì‹ ì¥íŠ¸ë¦¬ì™€ ì•Œê³ ë¦¬ì¦˜"
excerpt: "í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜, "
categories:
  - ds_ai
tags: [ì•Œê³ ë¦¬ì¦˜]
use_math: true
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---


<br>
<br>


# Minimum Spanning Tree(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
## Undirected Graph
**[ ì •ì˜ ]**
> ë¬´ë°©í–¥ ê·¸ë˜í”„ $G$ëŠ” ìœ í•œí•œ ì •ì  ì§‘í•© $V(vertex)$ê³¼, ê°„ì„  ì§‘í•© $E(edge)$ë¡œ êµ¬ì„±<br>
â€¢ ì •ì : $G$ì˜ ì •ì ì´ë¼ ë¶ˆë¦¼
â€¢ ê°„ì„ : ì •ì ë“¤ì˜ ìŒë“¤ë¡œ êµ¬ì„±ëœ ì§‘í•©, $G$ì˜ ê°„ì„ ì´ë¼ê³  ë¶€ë¦„<br> 
â€¢ í‘œê¸°: $G = (V, E)$

**[ ì˜ˆì‹œ ]**
![graph1](https://github.com/GangJiyeon/blog_img/blob/main/posting/al/graph_1.png)
â€¢ $|E| = 7$, $|V| = 5$
â€¢ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ëœ ë…¸ë“œ: ì´ì›ƒ
â€¢ ê·¸ë˜í”„ì—ëŠ” ìˆœí™˜ì€ ìˆì–´ì„œ íŠ¸ë¦¬ëŠ” ì•„ë‹˜

$V = {v_1, V_2, V_3, V_4, V_5}$
$E = {(V_1, V_2), (V_1, V_3), (V_2, V_3), (V_2, V_4), (V3, V_4), (V_3, V_5), (V_4, V_5)}$


## Tree Structure
**[ ì •ì˜ ]**
> â€¢ ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ ì—£ì§€ë¥¼ ì œê±°í•˜ì—¬ **ìˆœí™˜ êµ¬ì¡°ë¥¼ ì—†ì• ê³ ** ì—°ê²°ì„±ì„ ìœ ì§€í•œ ì„œë¸Œê·¸ë˜í”„
> â€¢ íŠ¸ë¦¬ëŠ” **ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³ ** ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²°ëœ êµ¬ì¡°  
> â€¢ ë©”ì‹œì§€ ì „íŒŒ, ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë“±ì—ì„œ ì„ í˜¸ë¨: ë¹„ìš©ì´ ì¤„ì–´ë“¦

**[ ì˜ˆì‹œ ]**
![graph2&3](https://github.com/GangJiyeon/blog_img/blob/main/posting/al/graph_2&3.png)
â€¢ (c) ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬: weight = 15  
â€¢ (d) ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬: weight = 10


## Minimum Spanning Tree
**[ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ì •ì˜ ]**
> ê·¸ë˜í”„ $G$ì˜ **ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³  ì—°ê²°ëœ** ë¶€ë¶„ ê·¸ë˜í”„ì´ë©° **íŠ¸ë¦¬**
> â€¢ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°–ëŠ” ì—°ê²°ëœ ë¶€ë¶„ ê·¸ë˜í”„ëŠ” ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì—¬ì•¼ í•¨
> â€¢ í•˜ì§€ë§Œ ëª¨ë“  ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê²ƒì€ ì•„ë‹˜

**[ íƒìš•ì (greedy) ì ‘ê·¼ ë°©ì‹ ì‚¬ìš© ]**

```c
F = âˆ…               // Initialize set of
                    // edges to empty
while (the instance is not solved){
    select an edge according to some locally optimal consideration;   // selection procedure
    if (adding the edge to F does not create a cycle)                 // feasibility check
        add it;
    if (T = (V, F) is a spanning tree)                                // solution check
        the instance is solved;
}
```


<br>
<br>
<br>



# Kruskal Algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜)
## Kruskal ì•Œê³ ë¦¬ì¦˜ì´ë€?
**[ ì •ì˜ ]**
> **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Minimum Spanning Tree)**ë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì¸ **Greedy Algorithm(íƒìš• ì•Œê³ ë¦¬ì¦˜)**
> â€¢ **ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ìµœì†Œí•œì˜ ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•˜ë©´ì„œ, ì „ì²´ ê°„ì„  ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œ**ê°€ ë˜ë„ë¡ êµ¬ì„±
> â€¢ Prim ì•Œê³ ë¦¬ì¦˜ê³¼ ë‹¬ë¦¬ **ê°„ì„  ì¤‘ì‹¬(edge-based)** ì•Œê³ ë¦¬ì¦˜

**[ ê¸°ë³¸ ì•„ì´ë””ì–´ ]**  
â€¢ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ ë¶€í„° í•˜ë‚˜ì”© ì„ íƒí•˜ë©´ì„œ,  
â€¢ **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡** ì£¼ì˜í•˜ë©°  
â€¢ $(|V| - 1)$ê°œì˜ ê°„ì„ ì„ ì„ íƒí•˜ë©´ ì™„ë£Œ

**[ í•µì‹¬ ë„êµ¬ ]**
â€¢ **Greedy ë°©ì‹**ìœ¼ë¡œ ê°„ì„  ì„ íƒ  
â€¢ **Union-Find (Disjoint Set)** ìë£Œêµ¬ì¡°ë¡œ ì‚¬ì´í´ íŒë‹¨

<br>

## ë™ì‘ ì˜ˆì‹œ (How it works)

1. **ì´ˆê¸° ê·¸ë˜í”„ ì£¼ì–´ì§**

2. **ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬**  
   ```
   sort â†’ (v2,v3), (v1,v2), (v3,v5), (v2,v5), (v1,v4), (v3,v4)
   ```

3. **ì„œë¡œì†Œ ì§‘í•© ì´ˆê¸°í™”**  
   - ì •ì  ìˆ˜ \( N \)
   - ê°„ì„  ìˆ˜ \( |E| \) = 1ë¶€í„° ì‹œì‘ â†’ \( |E| = N - 1 \)ì´ ë  ë•Œê¹Œì§€

4. **ê° ë‹¨ê³„ì—ì„œ**  
   - ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„  ì„ íƒ  
   - ì‚¬ì´í´ ì—†ìœ¼ë©´ ì¶”ê°€  
   - ì‚¬ì´í´ ìƒê¸°ë©´ ë¬´ì‹œ  
   - ì´ ê³¼ì •ì„ ë°˜ë³µ

5. **ëª¨ë“  ì •ì ì´ ì—°ê²°ëœ í•˜ë‚˜ì˜ ì§‘í•©ì´ ë˜ë©´ ì™„ë£Œ**

ğŸ“Œ ì•„ë˜ ìš”ì•½:
- ì„œë¡œì†Œ ì§‘í•©: \( V = \{V_1, V_2, ..., V_5\} \)  
- ì˜ˆ: \( \{v1\}, \{v2\}, ... \) â†’ \( \{v1, v2\} \)ë¡œ ë³‘í•©ë¨

---



## ì•Œê³ ë¦¬ì¦˜ ê°œìš” (Overview)

```c
F = âˆ…;                             // ê°„ì„  ì§‘í•© ì´ˆê¸°í™”

create disjoint subsets of V,      // ê° ì •ì ë§ˆë‹¤ í•˜ë‚˜ì”© ë¶„ë¦¬ëœ ì§‘í•© ìƒì„±
one for each vertex and 
containing only that vertex;

sort the edges in E in nondecreasing order;  // ê°„ì„ ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬

while (the instance is not solved){          // í•´ê²°ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë°˜ë³µ
    select next edge;                        // ê°„ì„  ì„ íƒ (ì„ íƒ ì ˆì°¨)
    
    if (the edge connects two vertices in disjoint subsets){  // ì í•©ì„± ê²€ì‚¬
        merge the subsets;
        add the edge to F;                   // ê°„ì„ ì„ ì¶”ê°€
    }

    if (all the subsets are merged)         // ëª¨ë“  ì •ì ì´ í•˜ë‚˜ì˜ ì§‘í•©ì´ë©´
        the instance is solved;             // í•´ê²° ì™„ë£Œ
}

//ë˜ëŠ” â€œê°„ì„ ì˜ ìˆ˜ \( |F| = |V| - 1 \)â€ì´ ë˜ë©´ ì¢…ë£Œí•´ë„ ë¨
```


## Kruskal ì•Œê³ ë¦¬ì¦˜ ì½”ë“œ (ì˜ì‚¬ì½”ë“œ)

```cpp
void kruskal(int n, int m,
             set_of_edges E,
             set_of_edges& F)
{
    index i, j;
    set_pointer p, q;
    edge e;

    Sort the m edges in E by weight in nondecreasing order;
    F = âˆ…;
    initial(n);                     // nê°œì˜ ë¶„ë¦¬ëœ ì§‘í•© ì´ˆê¸°í™”

    while (number of edges in F is less than n - 1){
        e = edge with least weight not yet considered;
        i, j = indices of vertices connected by e;
        p = find(i);
        q = find(j);

        if (!equal(p, q)){
            merge(p, q);           // ì§‘í•© ë³‘í•©
            add e to F;
        }
    }
}
```

ğŸ§  ì—°ì‚°:
- ì •ë ¬: \( m \log m \)  
- Union-Find ì—°ì‚°: \( \log n \)  
- ë”°ë¼ì„œ ì „ì²´ ì‹œê°„ë³µì¡ë„:  
  \[
  \Theta(m \log m + n)
  \]

---

### ğŸŸ© 4. ì‹œê°„ë³µì¡ë„ ë¶„ì„ (Analysis)

- ê°„ì„  ì •ë ¬ì´ Kruskalì˜ í•µì‹¬ ì‹œê°„ ì†Œëª¨ ìš”ì†Œ  
  \[
  W(m) \in \Theta(m \log m)
  \]

- ì—¬ê¸°ì„œ \( m \)ì€ ê°„ì„  ìˆ˜, \( n \)ì€ ì •ì  ìˆ˜  
- í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ **ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì •ë ¬ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ**ê°€ í•µì‹¬

