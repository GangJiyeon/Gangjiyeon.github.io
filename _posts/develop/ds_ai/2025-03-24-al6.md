---
title: "[ì•Œê³ ë¦¬ì¦˜] íƒìš• ì•Œê³ ë¦¬ì¦˜ê³¼ íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì ìš©"
excerpt: "í¬ë£¨ìŠ¤ì¹¼/í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜, ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜, ìŠ¤ì¼€ì¤„ë§ "
categories:
  - ds_ai
tags: [ì•Œê³ ë¦¬ì¦˜]
use_math: true
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---


<br>
<br>

# Greedy Algorithm
## Greedy ì•Œê³ ë¦¬ì¦˜ì˜ ê°œë…
**[ ê°œë… - Local Optimization Approach ]**  
> ì§€ì—½ì ì¸ ë°©ë²•ì„ ê°€ê³  ìµœì í™”ëœ(ë¼ê³  ë¯¿ëŠ”)ê°’ì„ ì„ íƒí•˜ëŠ” ë°©ë²•<br> 
> â€¢ ì¼ë ¨ì˜ ì„ íƒë“¤ì„ ìˆ˜í–‰í•˜ë©°, ê° ì„ íƒì€ ê·¸ ìˆœê°„ ê°€ì¥ ì¢‹ì•„ ë³´ì´ëŠ” ê²ƒì„ ì„ íƒí•¨  <br> 
> â€¢ ê° ì„ íƒì€ **êµ­ì†Œì ìœ¼ë¡œ ìµœì **ì¼ ìˆ˜ ìˆìœ¼ë‚˜, **ì „ì—­ì ìœ¼ë¡œ ìµœì **ì€ ì•„ë‹ ìˆ˜ ìˆìŒ



<br>

**[ ì˜ˆì‹œ: Exchanges Greedy Algorithm ]**

```c
while (there are more coins and the instance is not solved){
    grab the largest remaining coin;            // selection procedure
    if (adding the coin makes the change exceed the amount owed)  // feasibility check
        reject the coin;
    else
        add the coin to the change;
    if (the total value of the change equals the amount owed)     // solution check
        the instance is solved;
}
```

|ìµœì ì˜ ë°©ë²•|ìµœì ì´ ì•„ë‹Œ ë°©ë²•|
|---|---|
|||




<br>
<br>


# íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì ìš© ì˜ˆì‹œ
> ì´ ê¸€ì—ì„œëŠ” `í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜`, `í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜`, `ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜`, `ìŠ¤ì¼€ì¤„ë§` ì˜ íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì‚¬ìš© ì˜ˆì‹œë¥¼ ë‹¤ë£¬ë‹¤!


## `ì°¸ê³ ` Minimum Spanning Tree(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
**[ Undirected Graph ]**<br>
> ë¬´ë°©í–¥ ê·¸ë˜í”„ $G$ëŠ” ìœ í•œí•œ ì •ì  ì§‘í•© $V(vertex)$ê³¼, ê°„ì„  ì§‘í•© $E(edge)$ë¡œ êµ¬ì„±<br>
â€¢ ì •ì : $G$ì˜ ì •ì ì´ë¼ ë¶ˆë¦¼<br>
â€¢ ê°„ì„ : ì •ì ë“¤ì˜ ìŒë“¤ë¡œ êµ¬ì„±ëœ ì§‘í•©, $G$ì˜ ê°„ì„ ì´ë¼ê³  ë¶€ë¦„<br> 
â€¢ í‘œê¸°: $G = (V, E)$

**`ì˜ˆì‹œ`**

|ì´ë¯¸ì§€|ì„¤ëª…|
|:---:|---|
|![graph](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png)|â€¢ $n(E) = 7$, $n(V) = 5$<br>â€¢ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ëœ ë…¸ë“œ: ì´ì›ƒ<br>â€¢ ê·¸ë˜í”„ì—ëŠ” ìˆœí™˜ì€ ìˆì–´ì„œ íŠ¸ë¦¬ëŠ” ì•„ë‹˜<br>$V = \lbrace v_1, V_2, V_3, V_4, V_5\rbrace$<br>$E = \lbrace(V_1, V_2), (V_1, V_3), (V_2, V_3), (V_2, V_4), (V3, V_4), (V_3, V_5), (V_4, V_5)\rbrace$|

<br>

**[ Tree Structure ]**
> â€¢ ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ ì—£ì§€ë¥¼ ì œê±°í•˜ì—¬ **ìˆœí™˜ êµ¬ì¡°ë¥¼ ì—†ì• ê³ ** ì—°ê²°ì„±ì„ ìœ ì§€í•œ ì„œë¸Œê·¸ë˜í”„<br> 
> â€¢ íŠ¸ë¦¬ëŠ” **ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³ ** ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²°ëœ êµ¬ì¡°  <br> 
> â€¢ ë©”ì‹œì§€ ì „íŒŒ, ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë“±ì—ì„œ ì„ í˜¸ë¨: ë¹„ìš©ì´ ì¤„ì–´ë“¦

**`ì˜ˆì‹œ`**

<img src = "https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/%08graph_2%263.png" width = "500px">

â€¢ (c) ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬: weight = 15  <br>
â€¢ (d) ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬: weight = 10|

<br>

**[ Minimum Spanning Tree ]**
> ê·¸ë˜í”„ $G$ì˜ **ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ê³  ì—°ê²°ëœ** ë¶€ë¶„ ê·¸ë˜í”„ì´ë©° **íŠ¸ë¦¬**<br> 
> â€¢ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°–ëŠ” ì—°ê²°ëœ ë¶€ë¶„ ê·¸ë˜í”„ëŠ” ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì—¬ì•¼ í•¨<br> 
> â€¢ í•˜ì§€ë§Œ ëª¨ë“  ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê²ƒì€ ì•„ë‹˜

```c
F = âˆ…               // Initialize set of
                    // edges to empty
while (the instance is not solved){
    select an edge according to some locally optimal consideration;   // selection procedure
    if (adding the edge to F does not create a cycle)                 // feasibility check
        add it;
    if (T = (V, F) is a spanning tree)                                // solution check
        the instance is solved;
}
```


<br>
<br>
<br>

## Prim's Algorithm(í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜)

**[ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ê°œìš” ]**<br>
**1) ê·¸ë˜í”„ë¡œ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì§„í–‰ê³¼ì • ì•Œì•„ë³´ê¸°**<br>

|ë‹¨ê³„ë³„ ì´ë¯¸ì§€|ì„¤ëª…|ì§‘í•©|
|:---:|:---:|:---:|
|![í”„ë¦¼1](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png)|ìµœì†Œì‹ ì¥íŠ¸ë¦¬ ê²°ì •í•˜ê¸°|$V=\lbrace v_1, v_2, v_3, v_4, v_5\rbrace$, $Y=\lbrace \rbrace$|
|![í”„ë¦¼1-1](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_1.png)|ì •ì  $v_1$ ì„ íƒ|$Y=\lbrace v_1\rbrace$, $V-Y=\lbrace v_2, v_3, v_4, v_5\rbrace$|
|![í”„ë¦¼1-2](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_2.png)|ì •ì  $v_2$ ì„ íƒ(ì •ì  $v_1$ ì˜ ì´ì›ƒì´ë¯€ë¡œ)|$Y=\lbrace v_1, v_2\ rbrace$, $V-Y=\lbrace v_3, v_4, v_5\rbrace$|
|![í”„ë¦¼1-3](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_3.png)|ì •ì  $v_3$ ì„ íƒ($\lbrace v_1, v_2\rbrace$ ì˜ ì´ì›ƒì´ë¯€ë¡œ)|$Y=\lbrace v_1, v_2, v_3\rbrace$, $V-Y=\lbrace v_4, v_5\rbrace$|
|![í”„ë¦¼1-4](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_4.png)|ì •ì  $v_5$ ì„ íƒ($\lbrace v_1, v_2, v_3\rbrace$ ì˜ ì´ì›ƒì´ë¯€ë¡œ)|$Y=\lbrace v_1, v_2, v_3, v_5\rbrace$, $V-Y=\lbrace v_4\rbrace$|
|![í”„ë¦¼1-5](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_5.png)|ì •ì  $v_4$ ì„ íƒ|$Y=\lbrace v_1, v_2, v_3, v_4, v_5\rbrace$, $V-Y=\lbrace \rbrace$|

<br>

**2) ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ë¥¼ ì¸ì ‘í–‰ë ¬ë¡œ í‘œí˜„í•˜ê¸°**<br>

<img src = "https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/adjac.png" width = "300px">



```c
int adjacency_matrix[][] = 
{
    [0][2][3][âˆ][âˆ]
    [2][0][15][2][âˆ]
    [3][15][0][0][13]
    [0][2][âˆ][âˆ][9]
    [0][0][13][9][0]
}
```


**3) í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì˜ ê°œìš”**<br>

```c
F = âˆ…;          // Initialize set of edges to empty.
Y = {u1};       // Initialize set of vertices to contain only the first one.

while (the instance is not solved){
    select a vertex in V â€“ Y that is nearest to Y;   // selection procedure
    add the vertex to Y;
    add the edge to F;

    if (Y == V)    // solution check
        the instance is solved;
}
```

<br>

**[ ì˜ì‚¬ì½”ë“œ ë° ì‹¤í–‰ì˜ˆì‹œ ]**

```c
void prim (int n,
           const number W[][],
           set_of_edges F)
{
    index i, k, vnear;
    number min;
    edge e;
    index nearest[2..n];
    number distance[2..n];

    F = âˆ…;
    for (i = 2; i <= n; i++) {
        nearest[i] = 1;                        // ëª¨ë“  ì •ì ì— ëŒ€í•´ u1ì„ ê°€ì¥ ê°€ê¹Œìš´ ì •ì ìœ¼ë¡œ ì´ˆê¸°í™”
        distance[i] = W[1][i];                 // Yì—ì„œ iê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ê°€ì¤‘ì¹˜ë¡œ ì´ˆê¸°í™”
    }

    repeat (n âˆ’ 1 times) {                    // Yì— nâˆ’1ê°œì˜ ì •ì ì„ ì¶”ê°€
        min = âˆ;
        for (i = 2; i <= n; i++) {              // ëª¨ë“  ì •ì ì— ëŒ€í•´
            if (0 â‰¤ distance[i] < min) {      // Yì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  ì¤‘ ìµœì†Œ ê±°ë¦¬ ì„ íƒ
                min = distance[i];            // ìµœì†Œê°’ ê°±ì‹ 
                vnear = i;
            }
        }

        e = edge connecting vertices indexed
            by vnear and nearest[vnear];      // vnearì™€ ê°€ì¥ ê°€ê¹Œìš´ ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°„ì„  e
        add e to F;                           // eë¥¼ Fì— ì¶”ê°€
        distance[vnear] = âˆ’1;                 // vnearë¥¼ Yì— ì¶”ê°€í–ˆìŒì„ í‘œì‹œ

        for (i = 2; i <= n; i++) {          // Yì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì ë“¤ì— ëŒ€í•´
            if (W[i][vnear] < distance[i]) {  // vnearë¥¼ ê±°ì³ê°€ëŠ” ê±°ë¦¬ê°€ ë” ì§§ë‹¤ë©´
                distance[i] = W[i][vnear];    // ê±°ë¦¬ ê°±ì‹ 
                nearest[i] = vnear;           // ê°€ì¥ ê°€ê¹Œìš´ ì •ì  ê°±ì‹ 
            }
        }
    }
}
```

<img src = "https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png" width = "300px">



|W|$v_1$|$v_2$|$v_3$|$v_4$|$v_5$|
|:---:|:---:|:---:|:---:|:---:|
|$v_1$|0|1|3|âˆ|âˆ|
|$v_2$|1|0|3|6|âˆ|
|$v_3$|3|3|0|4|2|
|$v_4$|âˆ|6|4|0|5|
|$v_5$|âˆ|6|4|5|0|
|nearest|$v_n$ì— ì—°ê²°ëœ ë…¸ë“œ ì¤‘ ì§§ì€ ê²ƒì˜ ë²ˆí˜¸|1|1|1>2>3|1>3|
|distance|ê°€ì¤‘ì¹˜|1>-1|3>-1|âˆ>6>4>-1|âˆ>2>-1|

<br>

**[ ìˆ˜í•™ì  ì¦ëª… ]**

> í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ í•­ìƒ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ìƒì„±<br>
ì¦ëª…: ë°˜ë³µ ë£¨í”„ì˜ ê° ë‹¨ê³„ ì´í›„ ê°„ì„  ì§‘í•© Fê°€ ìœ ë§í•˜ë‹¤ëŠ” ê²ƒì„ ìˆ˜í•™ì  ê·€ë‚©ë²•ìœ¼ë¡œ ì¦ëª…


**1) ê¸°ì´ˆ ë‹¨ê³„ (Induction base)**<br>
> ì´ˆê¸° ìƒíƒœì¸ ê³µì§‘í•© FëŠ” ìœ ë§

**2) ê·€ë‚© ê°€ì • (Induction hypothesis)**<br>
> ë°˜ë³µ ë£¨í”„ì˜ ì–´ë–¤ ë‹¨ê³„ ì´í›„, í˜„ì¬ê¹Œì§€ ì„ íƒëœ ê°„ì„  ì§‘í•© Fê°€ ìœ ë§í•˜ë‹¤ê³  ê°€ì •

**3) ê·€ë‚© ë‹¨ê³„ (Induction step)**<br>
> â€¢ ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ì„ íƒë  ê°„ì„  eê°€ F âˆª {e}ë¥¼ ì—¬ì „íˆ ìœ ë§í•˜ê²Œ ë§Œë“¦ì„ ë³´ì—¬ì•¼ í•¨<br>
â€¢ ì„ íƒëœ ê°„ì„  eëŠ” Yì™€ V - Yë¥¼ ì—°ê²°í•˜ëŠ” ê°„ì„  ì¤‘ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ <br>
â€¢ ë”°ë¼ì„œ F âˆª {e}ëŠ” ì—¬ì „íˆ ìœ ë§í•œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ë¶€ë¶„ ì§‘í•©<br>

`ê²°ë¡ ` ë°˜ë³µ ë£¨í”„ê°€ ëë‚œ í›„ì˜ FëŠ” í•˜ë‚˜ì˜ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ê°€ ë¨



<br>
<br>
<br>


## `ì°¸ê³ ` Disjoint Set

**[ ì •ì˜ ]**
> â€¢ ì—¬ëŸ¬ ì›ì†Œê°€ ìˆì„ ë•Œ, ì´ë“¤ì„ **ì„œë¡œ ê²¹ì¹˜ì§€ ì•ŠëŠ” ì§‘í•©(ë¶„ë¦¬ ì§‘í•©)**ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ìë£Œêµ¬ì¡°<br>
â€¢ ëŒ€í‘œì ì¸ ìš©ë„: í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì‚¬ì´í´ì„ ë°©ì§€í•  ë•Œ ì‚¬ìš©

**[ ì£¼ìš”ì—°ì‚° ]**<br>
`makeset`<br>
â€¢ Universal Set: $U = $\lbrace A, B, C, D, E \rbrace$-> Sub set: $\lbrace a \rbrace$, $\lbrace b \rbrace$ ...<br>
ê° ì›ì†Œ xë¥¼ ìê¸° ìì‹ ë§Œ í¬í•¨í•˜ëŠ” í•˜ë‚˜ì˜ ë…ë¦½ ì§‘í•©ìœ¼ë¡œ ì´ˆê¸°í™”
`for (each x âˆˆ U) makeset(x)`<br>
â€¢ íŠ¸ë¦¬ë¡œ í‘œí˜„í•˜ë©´, ê° ë…¸ë“œëŠ” ìê¸° ìì‹ ì„ ë¶€ëª¨ë¡œ ê°€ë¦¬í‚´<br>
`find with set_pointer p or q`<br>
â€¢ ì›ì†Œ xê°€ ì†í•œ ì§‘í•©ì˜ **ëŒ€í‘œì(root)** ì°¾ê¸°<br>
â€¢ ë³´í†µ íŠ¸ë¦¬ì˜ ë£¨íŠ¸ë¥¼ ë°˜í™˜<br>
`merge(union)`<br>
â€¢ xì™€ yê°€ ì†í•œ ì„œë¡œ ë‹¤ë¥¸ ë‘ ì§‘í•©ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ëŠ” ì—°ì‚°<br>
â€¢ find(x)ì™€ find(y)ë¡œ ê°ê° ë£¨íŠ¸ë¥¼ ì°¾ì€ ë’¤, í•œìª½ íŠ¸ë¦¬ë¥¼ ë‹¤ë¥¸ ìª½ì— ë¶™ì„


**[ ì˜ˆì‹œ ]**




**[ ì‹œê°„ë³µì¡ë„ ]**<br>
â€¢ initial make set: 


**[ ì˜ì‚¬ì½”ë“œ ]**<br>
**1) Disjoint Setì˜ ê¸°ë³¸êµ¬í˜„ í˜•íƒœ**

```c
const int n = // universeì˜ ì›ì†Œ ê°œìˆ˜;

typedef int index;
typedef index set_pointer;
typedef index universe[1..n]; // universeëŠ” 1ë¶€í„° nê¹Œì§€ ì¸ë±ì‹±

universe U;

void makeset(index i) {
    U[i] = i;
}

set_pointer find(index i) {
    index j;
    j = i;
    while (U[j] != j)
        j = U[j];
    return j;
}

void merge(set_pointer p, set_pointer q) {
    if (p < q)
        U[q] = p;  // pê°€ ë³‘í•©ëœ ì§‘í•©ì„ ê°€ë¦¬í‚´
    else
        U[p] = q;  // qê°€ ë³‘í•©ëœ ì§‘í•©ì„ ê°€ë¦¬í‚´
}

bool equal(set_pointer p, set_pointer q) {
    if (p == q)
        return true;
    else
        return false;
}

void initial(int n) {
    index i;
    for (i = 1; i <= n; i++)
        makeset(i);
}
```

ë¬¸ì œì : skewed tree


**2) Disjoint Set Data Structure II (depth ê¸°ë°˜ ë³‘í•©)**



```c
const int n = // universeì˜ ì›ì†Œ ê°œìˆ˜;

typedef int index;
typedef index set_pointer;

struct nodetype {
    index parent;
    int depth;
};

typedef nodetype universe[1..n];
universe U;

void makeset(index i) {
    U[i].parent = i;
    U[i].depth = 0;
}

set_pointer find(index i) {
    index j;
    j = i;
    while (U[j].parent != j)
        j = U[j].parent;
    return j;
}

void merge(set_pointer p, set_pointer q) {
    if (U[p].depth == U[q].depth) {
        U[p].depth = U[p].depth + 1;
        U[q].parent = p;
    }
    else if (U[p].depth < U[q].depth) {
        U[p].parent = q;
    }
    else {
        U[q].parent = p;
    }
}

bool equal(set_pointer p, set_pointer q) {
    if (p == q)
        return true;
    else
        return false;
}

void initial(int n) {
    index i;
    for (i = 1; i <= n; i++)
        makeset(i);
}
```

**3) Disjoint Set Data Structure III (depth + smallest index ì¶”ì )**

```c
const int n = // universeì˜ ì›ì†Œ ê°œìˆ˜;

typedef int index;
typedef index set_pointer;

struct nodetype {
    index parent;
    int depth;
    int smallest;
};

typedef nodetype universe[1..n];
universe U;

void makeset(index i) {
    U[i].parent = i;
    U[i].depth = 0;
    U[i].smallest = i;
}

void merge(set_pointer p, set_pointer q) {
    if (U[p].depth == U[q].depth) {
        U[p].depth = U[p].depth + 1;
        U[q].parent = p;
        if (U[q].smallest < U[p].smallest)
            U[p].smallest = U[q].smallest;
    }
    else if (U[p].depth < U[q].depth) {
        U[p].parent = q;
        if (U[p].smallest < U[q].smallest)
            U[q].smallest = U[p].smallest;
    }
    else {
        U[q].parent = p;
        if (U[q].smallest < U[p].smallest)
            U[p].smallest = U[q].smallest;
    }
}

int small(set_pointer p) {
    return U[p].smallest;
}
```


<br>
<br>
<br>

## Kruskal Algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜)
**[ Kruskal ì•Œê³ ë¦¬ì¦˜ì´ë€ ]**<br>
**`ì •ì˜`**
> **ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST, Minimum Spanning Tree)**ë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì¸ **Greedy Algorithm(íƒìš• ì•Œê³ ë¦¬ì¦˜)**<br> 
> â€¢ **ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ìµœì†Œí•œì˜ ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•˜ë©´ì„œ, ì „ì²´ ê°„ì„  ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œ**ê°€ ë˜ë„ë¡ êµ¬ì„±<br> 
> â€¢ Prim ì•Œê³ ë¦¬ì¦˜ê³¼ ë‹¬ë¦¬ **ê°„ì„  ì¤‘ì‹¬(edge-based)** ì•Œê³ ë¦¬ì¦˜<br>
**`ê¸°ë³¸ ì•„ì´ë””ì–´`**  <br> 
â€¢ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ ë¶€í„° í•˜ë‚˜ì”© ì„ íƒí•˜ë©´ì„œ,  <br> 
â€¢ **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡** ì£¼ì˜í•˜ë©°  <br> 
â€¢ $(|V| - 1)$ê°œì˜ ê°„ì„ ì„ ì„ íƒí•˜ë©´ ì™„ë£Œ<br>
**`í•µì‹¬ ë„êµ¬`**<br> 
â€¢ **Greedy ë°©ì‹**ìœ¼ë¡œ ê°„ì„  ì„ íƒ  <br> 
â€¢ **ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì •ë ¬**<br> 
â€¢ **Union-Find (Disjoint Set)** ìë£Œêµ¬ì¡°ë¡œ ì‚¬ì´í´ íŒë‹¨

**[ ì‹œê°„ë³µì¡ë„ ë¶„ì„ (Analysis) ]**
> ê°„ì„  ì •ë ¬ì´ Kruskalì˜ í•µì‹¬ ì‹œê°„ ì†Œëª¨ ìš”ì†Œ: $W(m) \in \Theta(m \log m)$<br> 
â€¢ ì—¬ê¸°ì„œ $m$ì€ ê°„ì„  ìˆ˜, $n$ì€ ì •ì  ìˆ˜  <br>


**[ ë™ì‘ ì˜ˆì‹œ (How it works) ]**<br>

|ê·¸ë¦¼|ë‚´ìš©|
|:---:|---|
|1ë‹¨ê³„|ì´ˆê¸° ê·¸ë˜í”„ ì£¼ì–´ì§<br>|
|2ë‹¨ê³„|ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬<br>`(v1, v2)1`, `(v3, v5)2`, `(v1, v3)3`, `(v2, v3)3`, `(v3, v4)4`, `(v4, v5)5`, `(v2, v4)6`|
|3ë‹¨ê³„|ì„œë¡œì†Œ ì§‘í•© ì´ˆê¸°í™”<br>$n(V) = N$<br>$n(E_T) = N - 1$(ê°„ì„  ìˆ˜: 1ë¶€í„° ì‹œì‘,  N - 1ê¹Œì§€)|
|ë°˜ë³µ|â€¢ ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„  ì„ íƒ  <br>â€¢ ì‚¬ì´í´ ì—†ìœ¼ë©´ ì¶”ê°€, ì‚¬ì´í´ ìƒê¸°ë©´ ë¬´ì‹œ |
|ì¢…ë£Œ|ëª¨ë“  ì •ì ì´ ì—°ê²°ëœ í•˜ë‚˜ì˜ ì§‘í•©ì´ ë˜ë©´ ì™„ë£Œ| 

ğŸ“Œ ì•„ë˜ ìš”ì•½:<br>
â€¢ ì„œë¡œì†Œ ì§‘í•©: $V = \{V_1, V_2, ..., V_5\}$ <br>
â€¢ ì˜ˆ: $\{v1\}, \{v2\}, ... \) â†’ \( \{v1, v2\}$ë¡œ ë³‘í•©ë¨

<br>


**[ ì•Œê³ ë¦¬ì¦˜ ê°œìš” (Overview) ]**

```c
F = âˆ…;                             // ê°„ì„  ì§‘í•© ì´ˆê¸°í™”

create disjoint subsets of V,      // ê° ì •ì ë§ˆë‹¤ í•˜ë‚˜ì”© ë¶„ë¦¬ëœ ì§‘í•© ìƒì„±
one for each vertex and 
containing only that vertex;

sort the edges in E in nondecreasing order;  // ê°„ì„ ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬

while (the instance is not solved){          // í•´ê²°ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë°˜ë³µ
    select next edge;                        // ê°„ì„  ì„ íƒ (ì„ íƒ ì ˆì°¨)
    
    if (the edge connects two vertices in disjoint subsets){  // ì í•©ì„± ê²€ì‚¬
        merge the subsets;
        add the edge to F;                   // ê°„ì„ ì„ ì¶”ê°€
    }

    if (all the subsets are merged)         // ëª¨ë“  ì •ì ì´ í•˜ë‚˜ì˜ ì§‘í•©ì´ë©´
        the instance is solved;             // í•´ê²° ì™„ë£Œ
}

//ë˜ëŠ” ê°„ì„ ì˜ ìˆ˜|F| = |V| - 1ì´ ë˜ë©´ ì¢…ë£Œí•´ë„ ë¨
```

<br>


**[ Kruskal ì˜ì‚¬ì½”ë“œ ]**

```cpp
void kruskal(int n, int m,
             set_of_edges E,
             set_of_edges& F)
{
    index i, j;
    set_pointer p, q;
    edge e;

    Sort the m edges in E by weight in nondecreasing order;
    F = âˆ…;
    initial(n);                     // nê°œì˜ ë¶„ë¦¬ëœ ì§‘í•© ì´ˆê¸°í™”

    while (number of edges in F is less than n - 1){
        e = edge with least weight not yet considered;
        i, j = indices of vertices connected by e;
        p = find(i);
        q = find(j);

        if (!equal(p, q)){
            merge(p, q);           // ì§‘í•© ë³‘í•©
            add e to F;
        }
    }
}
```





<br>
<br>
<br>


## ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ SSP

**[ ê°œìš” ]**

```c
Y = {vâ‚};
F = âˆ…;

while (the instance is not solved) {
    select a vertex v from V âˆ’ Y, that has a
    shortest path from vâ‚, using only vertices
    in Y as intermediates;

    add the new vertex v to Y;
    add the edge (on the shortest path) that touches v to F;

    if (Y == V)
        the instance is solved;
}
```

**[ ì˜ì‚¬ì½”ë“œ ]**
<br>
`touch[i]`<br>
í˜„ì¬ vâ‚ì—ì„œ váµ¢ê¹Œì§€ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œ ì¤‘, ë§ˆì§€ë§‰ ê°„ì„  âŸ¨v, váµ¢âŸ©ì—ì„œì˜ vì˜ ì¸ë±ìŠ¤(ì¦‰, váµ¢ ë°”ë¡œ ì´ì „ì— ìˆëŠ” ì •ì  v)
prim ì•Œê³ ë¦¬ì¦˜ì—ì„œ nearestì™€ ìœ ì‚¬

`lenght[i]` <br>
vâ‚ì—ì„œ váµ¢ê¹Œì§€ Yì˜ ì •ì ë“¤ë§Œ ê²½ìœ í•˜ì—¬ ë„ë‹¬í•˜ëŠ”í˜„ì¬ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬
prim ì•Œê³ ë¦¬ì¦˜ì—ì„œ distanceì™€ ìœ ì‚¬


```c
void dijkstra (int n, const number W[][], set_of_edges& F)
{
    index i, vnear;
    edge e;
    index touch[2..n];
    number length[2..n];

    F = âˆ…;
    for (i = 2; i <= n; i++) {
        touch[i] = 1;                      // ëª¨ë“  ì •ì  váµ¢ì— ëŒ€í•´ vâ‚ì—ì„œ ì‹œì‘
        length[i] = W[1][i];               // vâ‚ì—ì„œ váµ¢ë¡œ ê°€ëŠ” ê°€ì¤‘ì¹˜ë¡œ ì´ˆê¸°í™”
    }

    repeat (n - 1 times) {
        min = âˆ;
        for (i = 2; i <= n; i++) {
            if (0 â‰¤ length[i] < min) {
                min = length[i];
                vnear = i;                // ê°€ì¥ ê°€ê¹Œìš´ ì •ì  vnear ì„ íƒ
            }
        }

        e = edge from vertex touch[vnear] to vertex vnear;
        add e to F;                       // ìµœë‹¨ ê²½ë¡œ ê°„ì„  ì¶”ê°€

        for (i = 2; i <= n; i++) {
            if (length[vnear] + W[vnear][i] < length[i]) {
                length[i] = length[vnear] + W[vnear][i];   // ê±°ë¦¬ ì—…ë°ì´íŠ¸
                touch[i] = vnear;                          // ê²½ë¡œ ì—…ë°ì´íŠ¸
            }
        }

        length[vnear] = -1;              // ì„ íƒ ì™„ë£Œëœ ì •ì  í‘œì‹œ
    }
}
```

**[ ì‹œê°„ë³µì¡ë„ ]**
> 2(n - 1)Â² âˆˆ Î¸(nÂ²)

**[ ì˜ˆì‹œ ]**

<br>
<br>
<br>

## ìŠ¤ì¼€ì¤„ë§ SSP

**[ ì •ì˜ ]**
> **ì—¬ëŸ¬ ì‘ì—…(ì‘ì—…ë“¤)**ì„ ì–´ë–¤ ìˆœì„œë¡œ ì²˜ë¦¬í• ì§€ ê²°ì •í•˜ëŠ” ê²ƒ<br>
â€¢ ì „ì²´ ì²˜ë¦¬ ì‹œê°„ì„ ì¤„ì¼ ìˆ˜ ìˆê³  **ê¸°í•œ(deadline)**ì„ ë§ì¶”ê±°ë‚˜ **ì´ìµ(profit)**ì„ ìµœëŒ€ë¡œ í•  ìˆ˜ ìˆìŒ<br>
â€¢ ì¢…ë¥˜: ë§ˆê°ê¸°í•œì´ ìˆëŠ” ìŠ¤ì¼€ì¤„ë§, ë§ˆê°ê¸°í•œì´ ì—†ëŠ” ìŠ¤ì¼€ì¤„ë§

<br>

**[ Scheduling (without deadlines) ]**

**1) í•µì‹¬ ì•„ì´ë””ì–´**
> ì„œë¹„ìŠ¤ ì‹œê°„ì´ ì§§ì€ ì‘ì—…ë¶€í„° ì²˜ë¦¬í•˜ë©´, ì „ì²´ ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„(total time in the system)ì´ ìµœì†Œí™”

**2) ì˜ˆì‹œ**<br>
â€¢ $t_1 = 5$, $t_2 = 10$, $t_3 = 4$<br>

| Job | Time in the System (ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„) |
|:---:|---|
| 1   | 5 (ì„œë¹„ìŠ¤ ì‹œê°„) |
| 2   | 5 (ëŒ€ê¸°) + 10 (ì„œë¹„ìŠ¤) = 15 |
| 3   | 5 (ëŒ€ê¸°) + 10 (ëŒ€ê¸°) + 4 (ì„œë¹„ìŠ¤) = 19 |

â€¢ `ì´í•©`: $5 + (5 + 10) + (5 + 10 + 4) = 39$<br>
â€¢ ê°€ëŠ¥í•œ ìŠ¤ì¼€ì¤„ ì¡°í•© & ì´ ì²´ë¥˜ ì‹œê°„ 

| Schedule  | Total Time in System |
|:---:|---|
| [1, 2, 3] | 39 |
| [1, 3, 2] | 33 |
| [2, 1, 3] | 44 |
| [2, 3, 1] | 43 |
| **[3, 1, 2]** | **32 (ìµœì )** |
| [3, 2, 1] | 37 |

**3) ì˜ì‚¬ì½”ë“œ**

```s
sort the jobs by service time in nondecreasing order

while (the instance is not solved):
    schedule the next job // selection + feasibility check

if (no more jobs):
    instance is solved
```


**4) ìµœì ì„± ì¦ëª… (Proof of Optimality)**<br>
`ì£¼ì¥`<br>
> ì „ì²´ ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„ì„ ìµœì†Œí™”í•˜ëŠ” ìœ ì¼í•œ ìŠ¤ì¼€ì¤„ì€
ì‘ì—…ë“¤ì„ ì„œë¹„ìŠ¤ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ(non-decreasing order) ì •ë ¬í•˜ëŠ” ê²ƒ


`ì¦ëª…(ê·€ë¥˜ë²•)`<br>

|êµ¬ë¶„|ë‚´ìš©|
|:---:|---|
|ê°€ì •|â€¢ $t_i$: ië²ˆì§¸ ì‘ì—…ì˜ ì„œë¹„ìŠ¤ ì‹œê°„ $(1 â‰¤ i â‰¤ nâˆ’1)$ <br>â€¢ ì´ ì‘ì—…ì€ ì–´ë–¤ ìµœì  ìŠ¤ì¼€ì¤„(ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„ì„ ìµœì†Œí™”í•˜ëŠ” ìŠ¤ì¼€ì¤„)ì—ì„œ ì‹¤í–‰ëœë‹¤ê³  ê°€ì •|
|ì¦ëª…|í•´ë‹¹ ìŠ¤ì¼€ì¤„ì´ ì„œë¹„ìŠ¤ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœì´ë¼ëŠ” ê²ƒì„ ë³´ì—¬ì•¼ í•œë‹¤<br>â€¢ ë§Œì•½ ì‘ì—…ë“¤ì´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì§€ ì•Šì•˜ë‹¤ë©´,
ì ì–´ë„ í•˜ë‚˜ì˜ ì¸ë±ìŠ¤ $i$ê°€ ì¡´ì¬í•´ì„œ: $t_i > t_{i+1}$<br>â€¢ ê¸°ì¡´ ìŠ¤ì¼€ì¤„ì—ì„œ ië²ˆì§¸ ì‘ì—…ê³¼ $(i+1)$ë²ˆì§¸ ì‘ì—…ì˜ **ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤**: 
â€£ $(i+1)$ë²ˆì§¸ ì‘ì—…ì€ ë” ì¼ì° ì²˜ë¦¬ë˜ë¯€ë¡œ **ëŒ€ê¸° ì‹œê°„ì´ ì¤„ì–´ë“¤ì–´** ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„ì´ $t_i$ë§Œí¼ **ê°ì†Œ**<br>â€£ **ië²ˆì§¸ ì‘ì—…**ì€ ë” **ëŠ¦ê²Œ** ì²˜ë¦¬ë˜ë¯€ë¡œ ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„ì´ $t_{i+1}$ë§Œí¼ **ì¦ê°€**<br>â€¢ ë”°ë¼ì„œ, ì „ì²´ ì‹œìŠ¤í…œ ì²´ë¥˜ ì‹œê°„ì€ ë‹¤ìŒê³¼ ê°™ë‹¤: $T' = T + t_{i+1} - t_i$|
|ê²°ë¡ |$t_i > t_{i+1}$ ì´ë¯€ë¡œ â†’ $T' < T$: ì›ë˜ ìŠ¤ì¼€ì¤„ë³´ë‹¤ ë” ë‚˜ì€ ìŠ¤ì¼€ì¤„ì´ ì¡´ì¬í•˜ê²Œ ë˜ì–´ **ëª¨ìˆœ**<br>ë”°ë¼ì„œ, **ìµœì  ìŠ¤ì¼€ì¤„ì€ ë°˜ë“œì‹œ ì„œë¹„ìŠ¤ ì‹œê°„ì´ ì˜¤ë¦„ì°¨ìˆœì¸ ìˆœì„œ**ì—¬ì•¼ í•œë‹¤|


<br> 

**[ Scheduling with Deadlines ]**<br>

**1) í•µì‹¬ ì•„ì´ë””ì–´**<br>
> ë§ˆê° ê¸°í•œ ë‚´ì— ìˆ˜í–‰ë˜ë©´ ìˆ˜ìµ(profit)ì„ ì–»ëŠ” ì‘ì—…ë“¤ ì¤‘ì—ì„œ ìµœëŒ€ ìˆ˜ìµì„ ì–»ì„ ìˆ˜ ìˆëŠ” ì¡°í•©ì„ ì°¾ëŠ”ë‹¤<br>

`ì°¸ê³ `<br>
â€¢ Feasible: ì¡°ê±´ì„ ë§Œì¡±í•´ì„œ ì‹¤ì œë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ ìƒíƒœë‹¤<br>
â€¢ ë§ˆê°ê¸°í•œì´ ìˆëŠ” ì‘ì—…ë“¤ ì¤‘ ì–´ë–¤ ì‘ì—…ë“¤ì„ ì„ íƒí•´ì„œ, ë§ˆê°ê¸°í•œì„ ì§€í‚¤ë©´ì„œ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ê²½ìš°

**2) ì˜ˆì œ (ì‘ì—…ë³„ ë§ˆê° ê¸°í•œê³¼ ìˆ˜ìµ)**

| Job | Deadline | Profit |
|-----|----------|--------|
| 1   | 2        | 30     |
| 2   | 1        | 35     |
| 3   | 2        | 25     |
| 4   | 1        | 40     |

`Feasibleí•œ ìŠ¤ì¼€ì¤„ (ê°€ëŠ¥í•œ ìˆœì„œ) ì˜ˆ`

| Schedule | Total Profit |
|----------|--------------|
| [1, 3]   | 55 |
| [2, 1]   | 65 |
| [2, 3]   | 60 |
| [3, 1]   | 55 |
| **[4, 1]** | **âœ… 70 (ìµœì )** |
| [4, 3]   | 65 |

`Unfeasibleí•œ ìŠ¤ì¼€ì¤„`<br>
â€¢ [1, 2] â†’ deadline ë§Œì¡±í•˜ì§€ ëª»í•¨<br>


**3) ê·¸ë¦¬ë”” ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜**<br>
â€¢ ëª¨ë“  ê°€ëŠ¥í•œ ìŠ¤ì¼€ì¤„ì„ ê³ ë ¤í•˜ë ¤ë©´: ê²½ìš°ì˜ ìˆ˜ê°€ ë§ë‹¤ (Factorial timeì´ ì†Œìš”ë¨)<br>
â€¢ ê·¸ë¦¬ë””(Greedy) ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ê³„í•˜ë ¤ë©´<br>
> ì‘ì—…ë“¤ì„ **ìˆ˜ìµ(profit)** ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬, ì‘ì—…ì„ í•˜ë‚˜ì”© ê°€ëŠ¥í•œ ê²½ìš°ì— **ìŠ¤ì¼€ì¤„ì— ì‚½ì…**

â€¢ ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ë¥¼ ìœ„í•œ ì •ì˜

| Feasible Sequence(ê°€ëŠ¥í•œ ì‘ì—… ìˆœì„œ)| Feasible Set (ê°€ëŠ¥í•œ ì‘ì—… ì§‘í•©)|
|---|---|
| [1, 3], [3, 1]| {1, 2} |
| [2, 1] | {2, 3} |
| [2, 3]| {1, 4} |
| [4, 1] | {2, 4} |
| [4, 3]| {3, 4}  |

`ì°¸ê³ ` ì§‘í•©ì˜ ìˆœì„œê°€ ë‹¬ë¼ë„ profitì´ ë‹¬ë¼ì§€ì§€ëŠ” ì•ŠëŠ”ë‹¤ â†’ ì´ì „ë§Œí¼ ì—„ì²­ë‚˜ê²Œ ì¤‘ìš”í•˜ì§€ëŠ” ì•Šë‹¤

â€¢ ê·¸ë¦¬ë”” ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ì˜ ëª©í‘œ<br>
> ê°€ëŠ¥í•œ ìˆœì„œ ì¤‘ì—ì„œ **ì´ ìˆ˜ìµì´ ìµœëŒ€ê°€ ë˜ëŠ” ìˆœì„œ**ë¥¼ ì°¾ëŠ”ë‹¤<br>
ğŸ‘‰ ì˜ë¯¸: **optimal sequence (ìµœì  ìˆœì„œ)**<br>
ğŸ‘‰ **optimal set of jobs** = ê·¸ ìµœì  ìˆœì„œì— í¬í•¨ëœ ì‘ì—…ë“¤ì˜ ì§‘í•©


**4) ì˜ì‚¬ì½”ë“œ**<br>

```c
Sort the jobs in nonincreasing order of profit
sort(jobs by profit in descending order)

S = âˆ…   // Initialize selected job set

while (there are jobs left to consider) {
    job = select next job from the sorted list

    if (S âˆª {job} is feasible) {
        S = S âˆª {job}   // Add job to schedule
    }

    if (no more jobs to consider) {
        break   // Problem instance is solved
    }
}

return S  // S is the set of scheduled jobs with maximum total profit
```

| Job | Deadline | Profit |
|-----|----------|--------|
| 1   | 3        | 40     |
| 2   | 1        | 35     |
| 3   | 1        | 30     |
| 4   | 3        | 25     |
| 5   | 1        | 20     |
| 6   | 3        | 15     |
| 7   | 2        | 10     |


â€¢ SëŠ” âˆ…ë¡œ ì‹œì‘í•¨<br>
â€¢ S = {1} â†’ [1]ì€ ê°€ëŠ¥í•˜ë¯€ë¡œ ì„ íƒë¨  <br>
â€¢ S = {1, 2} â†’ [2, 1]ì€ ê°€ëŠ¥í•˜ë¯€ë¡œ ì„ íƒë¨<br>
â€¢ {1, 2, 3} â†’ ë¶ˆê°€ëŠ¥í•œ ìˆœì„œì´ë¯€ë¡œ ì œì™¸ë¨<br>
   â†’ ëŒ€ì‹  {1, 2, 4}ëŠ” [2, 1, 4]ê°€ ê°€ëŠ¥í•˜ë¯€ë¡œ ì„ íƒë¨  <br>
â€¢ {1, 2, 4, 5} â†’ ë¶ˆê°€ëŠ¥í•œ ìˆœì„œì´ë¯€ë¡œ ì œì™¸  <br>
â€¢ {1, 2, 4, 6} â†’ ë¶ˆê°€ëŠ¥  <br>
â€¢ {1, 2, 4, 7} â†’ ë¶ˆê°€ëŠ¥  <br>

 **ìµœì¢… ì„ íƒëœ ì‘ì—… ì§‘í•©:** {2, 1, 4}



**5) Identification of Feasibility (ê°€ëŠ¥ì„± íŒë‹¨ ê¸°ì¤€)**

> **Sê°€ feasible(ê°€ëŠ¥í•œ ì§‘í•©)**ì´ê¸° ìœ„í•œ ì¡°ê±´:  
> Sì— í¬í•¨ëœ ì‘ì—…ë“¤ì„ **ë§ˆê°ê¸°í•œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œ ìˆœì„œê°€ feasibleí•œ ê²½ìš°ì—ë§Œ** SëŠ” feasibleí•˜ë‹¤.

---

**ì¦ëª…:**  
Sê°€ feasibleí•˜ë‹¤ê³  í•˜ì. ê·¸ë ‡ë‹¤ë©´ ì ì–´ë„ í•˜ë‚˜ì˜ feasibleí•œ ìˆœì„œê°€ ì¡´ì¬í•œë‹¤.
job xê°€ job yë³´ë‹¤ ë¨¼ì € ìŠ¤ì¼€ì¤„ë§ë˜ì–´ ìˆê³ , job yì˜ ë§ˆê°ê¸°í•œì´ ë” ì´ë¥´ë‹¤ê³  ê°€ì •í•˜ì

ì´ ë‘ ì‘ì—…ì˜ ìˆœì„œë¥¼ ë°”ê¾¸ì–´ë„ ë°”ê¾¼ ìˆœì„œë„ ì—¬ì „íˆ feasibleí•¨
â€¢  job yëŠ” ë” ë¹¨ë¦¬ ì‹œì‘í•˜ê²Œ ë˜ë¯€ë¡œ ë§ˆê°ê¸°í•œì„ ì§€í‚¬ ìˆ˜ ìˆê³   
â€¢  job xë„ ì´ì „ ì‹œê°„ëŒ€ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë§ˆê°ê¸°í•œ ë‚´ì— ì™„ë£Œ ê°€ëŠ¥

ì´ëŸ¬í•œ ì„±ì§ˆì„ ë°˜ë³µì ìœ¼ë¡œ ì ìš©í•˜ì—¬ **Exchange Sort**ë¥¼ í†µí•´  
ì •ë ¬ëœ ìˆœì„œê°€ feasibleí•˜ë‹¤ë©´ ì „ì²´ë„ feasibleí•˜ë‹¤ê³  ì¦ëª…í•  ìˆ˜ ìˆìŒ

ê²°ë¡ ì ìœ¼ë¡œ,  **ì •ë ¬ëœ ìˆœì„œê°€ feasibleí•˜ë©´ â†’ í•´ë‹¹ ì§‘í•© SëŠ” feasibleí•˜ë‹¤.**


 **Feasibility íŒë³„ ì˜ˆì‹œ**

- ì§‘í•© {1, 2, 4, 7}ì˜ ê°€ëŠ¥í•œ ìˆœì„œ ì¤‘ í•˜ë‚˜ê°€ [2, 7, 1, 4]ë¼ê³  í•˜ì.
- ê° ì‘ì—…ì˜ ë§ˆê°ê¸°í•œì„ í•´ë‹¹ ìˆœì„œëŒ€ë¡œ í‘œì‹œí•˜ë©´:  
  `1 2 3 3` (ì‹œê°„ ìŠ¬ë¡¯)
- ì´ 4ê°œì˜ ì‘ì—…ì„ 3ê°œì˜ ì‹œê°„ ìŠ¬ë¡¯ì— ë„£ìœ¼ë ¤ í•˜ë¯€ë¡œ **ë¶ˆê°€ëŠ¥** (feasibleí•˜ì§€ ì•ŠìŒ)


### ğŸ”¹ **C++ ìŠ¤íƒ€ì¼ ì˜ì‚¬ì½”ë“œ**

```cpp

**ë¬¸ì œ ì •ì˜:**  
ê° ì‘ì—…ì€ ë§ˆê°ê¸°í•œ ë‚´ì— ì™„ë£Œë˜ì–´ì•¼ë§Œ ìˆ˜ìµì„ ì–»ì„ ìˆ˜ ìˆë‹¤.  
ìµœëŒ€ ìˆ˜ìµì„ ì–»ì„ ìˆ˜ ìˆëŠ” ì‘ì—…ë“¤ì˜ ìŠ¤ì¼€ì¤„ì„ ê²°ì •í•˜ë¼.

**ì…ë ¥:**
n: ì‘ì—…ì˜ ê°œìˆ˜
deadline[i]: ië²ˆì§¸ ì‘ì—…ì˜ ë§ˆê°ê¸°í•œ  
ì‘ì—…ë“¤ì€ ìˆ˜ìµ ê¸°ì¤€ìœ¼ë¡œ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ë˜ì–´ ìˆë‹¤ê³  ê°€ì •

**ì¶œë ¥:**
- ìµœëŒ€ ìˆ˜ìµì„ ë‚´ëŠ” ì‘ì—… ìˆœì„œ \( J \)

void schedule(int n, const int deadline[], sequence_of_integer& J) {
    index i;
    sequence_of_integer K;

    J = [1];
    for (i = 2; i <= n; ++i) {
        K = J with i added according to nondecreasing values of deadline[i];
        if (K is feasible)
            J = K;
    }
}
```


| Job | Deadline |
|-----|----------|
| 1   | 3        |
| 2   | 1        |
| 3   | 1        |
| 4   | 3        |
| 5   | 1        |
| 6   | 3        |
| 7   | 2        |

**ë‹¨ê³„ë³„ ì‹¤í–‰:**
1. J = [1]
2. K = [2, 1] â†’ feasible â†’ J = [2, 1]
3. K = [2, 3, 1] â†’ not feasible â†’ reject
4. K = [2, 1, 4] â†’ feasible â†’ J = [2, 1, 4]
5. K = [2, 5, 1, 4] â†’ not feasible â†’ reject
6. K = [2, 1, 6, 4] â†’ not feasible â†’ reject
7. K = [2, 7, 1, 4] â†’ not feasible â†’ reject

âœ… **ìµœì¢… ê²°ê³¼:**  
\( J = [2, 1, 4] \)

---

### ğŸ”¹ **ìµœì•… ì‹œê°„ ë³µì¡ë„ (Worst-Case Time Complexity)**

- **ê¸°ë³¸ ì—°ì‚°:**  
  - ì‘ì—… ì •ë ¬ ì‹œ: ë¹„êµ í•„ìš”  
  - ë§¤ ë°˜ë³µë§ˆë‹¤: \( J + i \) ì§‘í•©ì´ feasibleí•œì§€ í™•ì¸í•˜ëŠ” ë¹„êµ í•„ìš”

- **ì…ë ¥ í¬ê¸°: $n$ ì‘ì—… ìˆ˜
- **ì •ë ¬ ì‹œê°„:$\Theta(n \log n)$
- **ë°˜ë³µë¬¸ ë‚´ ë¹„êµ:**  
  - \( i \)ë²ˆì§¸ ë£¨í”„ì—ì„œ ìµœëŒ€ \( i-1 \)ê°œì˜ ë¹„êµ â†’ í•©ì¹˜ë©´ \( \sum_{i=2}^n [(i-1) + i] = n^2 - 1 \in \Theta(n^2) \)

$W(n) \in \Theta(n^2)$

