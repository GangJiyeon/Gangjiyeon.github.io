---
title: "[알고리즘] 탐욕 알고리즘과 탐욕 알고리즘의 적용"
excerpt: "크루스칼/프림 알고리즘, 다익스트라 알고리즘, "
categories:
  - ds_ai
tags: [알고리즘]
use_math: true
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---


<br>
<br>

# Greedy Algorithm
## Greedy 알고리즘의 개념
**[ 개념 - Local Optimization Approach ]**  
> 지엽적인 방법을 가고 최적화된(라고 믿는)값을 선택하는 방법<br> 
> • 일련의 선택들을 수행하며, 각 선택은 그 순간 가장 좋아 보이는 것을 선택함  <br> 
> • 각 선택은 **국소적으로 최적**일 수 있으나, **전역적으로 최적**은 아닐 수 있음

<br>

**[ 예시: Exchanges Greedy Algorithm ]**

```c
while (there are more coins and the instance is not solved){
    grab the largest remaining coin;            // selection procedure
    if (adding the coin makes the change exceed the amount owed)  // feasibility check
        reject the coin;
    else
        add the coin to the change;
    if (the total value of the change equals the amount owed)     // solution check
        the instance is solved;
}
```

|최적의 방법|최적이 아닌 방법|
|---|---|
|||




<br>
<br>


# 탐욕 알고리즘의 적용 예시
> 이 글에서는 `크루스칼 알고리즘`, `프림 알고리즘`, `다익스트라 알고리즘`, `스케줄링` 의 탐욕 알고리즘의 사용 예시를 다룬다!


## `참고` Minimum Spanning Tree(최소 신장 트리)
**[ Undirected Graph ]**<br>
> 무방향 그래프 $G$는 유한한 정점 집합 $V(vertex)$과, 간선 집합 $E(edge)$로 구성<br>
• 정점: $G$의 정점이라 불림<br>
• 간선: 정점들의 쌍들로 구성된 집합, $G$의 간선이라고 부름<br> 
• 표기: $G = (V, E)$

**`예시`**

|이미지|설명|
|:---:|---|
|![graph](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png)|• $n(E) = 7$, $n(V) = 5$<br>• 직접적으로 연결된 노드: 이웃<br>• 그래프에는 순환은 있어서 트리는 아님<br>$V = \lbracev_1, V_2, V_3, V_4, V_5\rbrace$<br>$E = \lbrace(V_1, V_2), (V_1, V_3), (V_2, V_3), (V_2, V_4), (V3, V_4), (V_3, V_5), (V_4, V_5)\rbrace$|

<br>

**[ Tree Structure ]**
> • 그래프에서 일부 엣지를 제거하여 **순환 구조를 없애고** 연결성을 유지한 서브그래프<br> 
> • 트리는 **모든 정점을 포함하고** 사이클이 없는 연결된 구조  <br> 
> • 메시지 전파, 네트워크 연결 등에서 선호됨: 비용이 줄어듦

**`예시`**
![graph2&3](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/%08graph_2%263.png)
• (c) 스패닝 트리: weight = 15  <br>
• (d) 최소 스패닝 트리: weight = 10


**[ Minimum Spanning Tree ]**
> 그래프 $G$의 **모든 정점을 포함하고 연결된** 부분 그래프이며 **트리**<br> 
> • 최소 가중치를 갖는 연결된 부분 그래프는 스패닝 트리여야 함<br> 
> • 하지만 모든 스패닝 트리가 최소 가중치를 가지는 것은 아님

```c
F = ∅               // Initialize set of
                    // edges to empty
while (the instance is not solved){
    select an edge according to some locally optimal consideration;   // selection procedure
    if (adding the edge to F does not create a cycle)                 // feasibility check
        add it;
    if (T = (V, F) is a spanning tree)                                // solution check
        the instance is solved;
}
```


<br>
<br>
<br>

## Prim's Algorithm(프림 알고리즘)

**[ 프림 알고리즘의 개요 ]**<br>
**1) 그래프로 프림 알고리즘의 진행과정 알아보기**<br>

|단계별 이미지|설명|집합|
|:---:|:---:|:---:|
|![프림1](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png)|최소신장트리 결정하기|$V=\{v_1, v_2, v_3, v_4, v_5\}$, $Y=\{\}$|
|![프림1-1](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_1.png)|정점 $v_1$ 선택|$Y=\{v_1\}$, $V-Y=\{v_2, v_3, v_4, v_5\}$|
|![프림1-2](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_2.png)|정점 $v_2$ 선택(정점 $v_1$ 의 이웃이므로)|$Y=\{v_1, v_2\}$, $V-Y=\{v_3, v_4, v_5\}$|
|![프림1-3](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_3.png)|정점 $v_3$ 선택($\{v_1, v_2\}$ 의 이웃이므로)|$Y=\{v_1, v_2, v_3\}$, $V-Y=\{v_4, v_5\}$|
|![프림1-4](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_4.png)|정점 $v_5$ 선택($\{v_1, v_2, v_3\}$ 의 이웃이므로)|$Y=\{v_1, v_2, v_3, v_5\}$, $V-Y=\{v_4\}$|
|![프림1-5](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1_5.png)|정점 $v_4$ 선택|$Y=\{v_1, v_2, v_3, v_4, v_5\}$, $V-Y=\{\}$|

<br>

**2) 가중치 그래프를 인접행렬로 표현하기**<br>

<img src = "https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/adjac.png" width = "300px">

![가중치 그래프](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/adjac.png)

```c
int adjacency_matrix[][] = 
{
    [0][2][3][∞][∞]
    [2][0][15][2][∞]
    [3][15][0][0][13]
    [0][2][∞][∞][9]
    [0][0][13][9][0]
}
```


**3) 프림 알고리즘의 개요**<br>

```c
F = ∅;          // Initialize set of edges to empty.
Y = {u1};       // Initialize set of vertices to contain only the first one.

while (the instance is not solved){
    select a vertex in V – Y that is nearest to Y;   // selection procedure
    add the vertex to Y;
    add the edge to F;

    if (Y == V)    // solution check
        the instance is solved;
}
```

<br>

**[ 의사코드 및 실행예시 ]**

```c
void prim (int n,
           const number W[][],
           set_of_edges F)
{
    index i, k, vnear;
    number min;
    edge e;
    index nearest[2..n];
    number distance[2..n];

    F = ∅;
    for (i = 2; i <= n; i++) {
        nearest[i] = 1;                        // 모든 정점에 대해 u1을 가장 가까운 정점으로 초기화
        distance[i] = W[1][i];                 // Y에서 i까지의 거리를 가중치로 초기화
    }

    repeat (n − 1 times) {                    // Y에 n−1개의 정점을 추가
        min = ∞;
        for (i = 2; i <= n; i++) {              // 모든 정점에 대해
            if (0 ≤ distance[i] < min) {      // Y에 포함되지 않은 정점 중 최소 거리 선택
                min = distance[i];            // 최소값 갱신
                vnear = i;
            }
        }

        e = edge connecting vertices indexed
            by vnear and nearest[vnear];      // vnear와 가장 가까운 정점을 연결하는 간선 e
        add e to F;                           // e를 F에 추가
        distance[vnear] = −1;                 // vnear를 Y에 추가했음을 표시

        for (i = 2; i <= n; i++) {          // Y에 포함되지 않은 정점들에 대해
            if (W[i][vnear] < distance[i]) {  // vnear를 거쳐가는 거리가 더 짧다면
                distance[i] = W[i][vnear];    // 거리 갱신
                nearest[i] = vnear;           // 가장 가까운 정점 갱신
            }
        }
    }
}
```


![프림1](https://raw.githubusercontent.com/GangJiyeon/blog_img/refs/heads/main/posting/al/graph_1.png)

|W|$v_1$|$v_2$|$v_3$|$v_4$|$v_5$|
|:---:|:---:|:---:|:---:|:---:|
|$v_1$|0|1|3|∞|∞|
|$v_2$|1|0|3|6|∞|
|$v_3$|3|3|0|4|2|
|$v_4$|∞|6|4|0|5|
|$v_5$|∞|6|4|5|0|
|nearest|$v_n$에 연결된 노드 중 짧은 것의 번호|1|1|1>2>3|1>3|
|distance|가중치|1>-1|3>-1|∞>6>4>-1|∞>2>-1|


**[ 수학적 증명 ]**

> 프림 알고리즘은 항상 최소 신장 트리를 생성<br>
증명: 반복 루프의 각 단계 이후 간선 집합 F가 유망하다는 것을 수학적 귀납법으로 증명


**1) 기초 단계 (Induction base)**<br>
> 초기 상태인 공집합 F는 유망

**2) 귀납 가정 (Induction hypothesis)**<br>
> 반복 루프의 어떤 단계 이후, 현재까지 선택된 간선 집합 F가 유망하다고 가정

**3) 귀납 단계 (Induction step)**<br>
> • 다음 단계에서 선택될 간선 e가 F ∪ {e}를 여전히 유망하게 만듦을 보여야 함<br>
• 선택된 간선 e는 Y와 V - Y를 연결하는 간선 중 가중치가 가장 작은 간선<br>
• 따라서 F ∪ {e}는 여전히 유망한 최소 신장 트리의 부분 집합<br>

`결론` 반복 루프가 끝난 후의 F는 하나의 최소 신장 트리가 됨



<br>
<br>
<br>


## Kruskal Algorithm (크루스칼 알고리즘)
**[ Kruskal 알고리즘이란 ]**<br>
**`정의`**
> **최소 신장 트리(MST, Minimum Spanning Tree)**를 구하는 대표적인 **Greedy Algorithm(탐욕 알고리즘)**<br> 
> • **그래프의 모든 정점을 최소한의 간선으로 연결하면서, 전체 간선 가중치의 합이 최소**가 되도록 구성<br> 
> • Prim 알고리즘과 달리 **간선 중심(edge-based)** 알고리즘

**`기본 아이디어`**  <br> 
• 가중치가 가장 작은 간선부터 하나씩 선택하면서,  <br> 
• **사이클이 생기지 않도록** 주의하며  <br> 
• $(|V| - 1)$개의 간선을 선택하면 완료

**`핵심 도구`**<br> 
• **Greedy 방식**으로 간선 선택  
• **Union-Find (Disjoint Set)** 자료구조로 사이클 판단

<br>

**[ 동작 예시 (How it works) ]**<br>

|그림|내용|
|:---:|---|
|1단계|초기 그래프 주어짐<br>|
|2단계|간선들을 가중치 기준으로 정렬<br>`(v1, v2)1`, `(v3, v5)2`, `(v1, v3)3`, `(v2, v3)3`, `(v3, v4)4`, `(v4, v5)5`, `(v2, v4)6`|
|3단계|서로소 집합 초기화<br>$n(V) = N$<br>$n(E_T) = N - 1$(간선 수: 1부터 시작,  N - 1까지)|
|반복|• 최소 가중치 간선 선택  <br>• 사이클 없으면 추가, 사이클 생기면 무시 |
|종료|모든 정점이 연결된 하나의 집합이 되면 완료| 

📌 아래 요약:<br>
• 서로소 집합: $V = \{V_1, V_2, ..., V_5\}$ <br>
• 예: $\{v1\}, \{v2\}, ... \) → \( \{v1, v2\}$로 병합됨



**[ 알고리즘 개요 (Overview) ]**

```c
F = ∅;                             // 간선 집합 초기화

create disjoint subsets of V,      // 각 정점마다 하나씩 분리된 집합 생성
one for each vertex and 
containing only that vertex;

sort the edges in E in nondecreasing order;  // 간선을 오름차순으로 정렬

while (the instance is not solved){          // 해결되지 않았다면 반복
    select next edge;                        // 간선 선택 (선택 절차)
    
    if (the edge connects two vertices in disjoint subsets){  // 적합성 검사
        merge the subsets;
        add the edge to F;                   // 간선을 추가
    }

    if (all the subsets are merged)         // 모든 정점이 하나의 집합이면
        the instance is solved;             // 해결 완료
}

//또는 간선의 수|F| = |V| - 1이 되면 종료해도 됨
```


**[ Kruskal 의사코드 ]**

```cpp
void kruskal(int n, int m,
             set_of_edges E,
             set_of_edges& F)
{
    index i, j;
    set_pointer p, q;
    edge e;

    Sort the m edges in E by weight in nondecreasing order;
    F = ∅;
    initial(n);                     // n개의 분리된 집합 초기화

    while (number of edges in F is less than n - 1){
        e = edge with least weight not yet considered;
        i, j = indices of vertices connected by e;
        p = find(i);
        q = find(j);

        if (!equal(p, q)){
            merge(p, q);           // 집합 병합
            add e to F;
        }
    }
}
```


**[ 시간복잡도 분석 (Analysis) ]**
> 간선 정렬이 Kruskal의 핵심 시간 소모 요소  
$W(m) \in \Theta(m \log m)$

- 여기서 $m$은 간선 수, $n$은 정점 수  
- 크루스칼 알고리즘은 **가중치 기준 정렬 + 유니온 파인드**가 핵심


<br>
<br>
<br>
