---
title: "[자바 객체지향] 클래스와 객체"
excerpt: "클래스와 객체, 생성자, 오버로딩, "
categories:
	- language
tags: [자바객체지향, Java]
toc: true
author_profile: true 
sidebar:
	nav: "docs"
---




# 클래스와 객체 기본 개념
## 클래스, 객체, 객체지향프로그래밍의 정의
**[ 클래스(Class) ]**
> 1. 객체(objext)의 `속성, 특성`, `기능/행위`를 정의하는 논리적 구조<br>
2. 새로운 자료형(data type)의 정의: a complex data type, 참조 자료형

• 객체지향 프로그래밍의 기반: 객체의 설계도(틀, template, design)<br>
• 속성을 표현하는 `변수`들과 기능을 표현하는 `메소드`들을 `캡슐화(encapsulation)`함
• 생성: 객체(object) = 클래스의 인스턴스(instance, 사례)
• 구성
|분류|내용|
|:---:|---|
|필드, 멤버 변수|member variables (class var, instance var)<br>static/class-wide<br>• class var: static/class-wide-global, 전역<br>• instance var: Local (객체 안, within an object)|
|메쏘드, 멤버 함수|methods (= member functions)|



ü they are either open public or hidden private
(공개) (비공개)

**[ 객체(Object) ]**
> 특징(속성, variable)과 동작(기능, method)의 조합체<br>
• 메모리 할당을 받는 `실체: instance(인스턴스)`<br>
• 프로그램 `실행 중에 생성`되는 실체

**[ 객체지향 프로그래밍(object-oriented programming (OOP)) ]**
> 특징(속성, variable)과 동작(기능, method)의 조합체<br>
• `클래스`의 `집합(= program)`을 `설계`하는 작업<br>
• 컴퓨터 수행작업을 `객체들 사이`의 `상호작용(msg 전달)`으로 표현<br>


**[ 캡슐화 (Encapsulation) ]**
Class design -> encapsulation of information (캡슐화) and
designation of information visibility (정보 가시성/접근 지정)
선택적으로 정보 가시성을 제한하는 것


```java
// 정보 공개
public variables
public functions

// 정보 은닉(information hiding)
private variables
private functions
```

<br>
<br>
<br>

# 객체 생성과 초기화
## 생성자(Constructor)의 역할
**[ Constructor (생성자) ]**
> 특별한 메쏘드 : 객체를 만들고(instantiation, by ‘new’ 명령),
또 초기화(initialization)도 수행
• 생성자 이름 = 클래스 이름
• return value/type 지정 불필요
• [동명의] 생성자, 여러 개 있어도 좋다 (‘overloading’ ‘생성
자 중복’) – 인자 수/형식은 구분되어야 한다

**[ default Constructor (생성자) ]**
> 별도의 생성자가 없을 때 컴파일러가 자동 만들어 준다

```java
class Circle {
  int r, x, y;

  Circle() {} //기본으로 제공
} 
```

• 형식만 갖추어 주고 (한 가지 일 외에) 별도의 작업은 없다
• 기능: 객체 생성 `Circle o = new Circle();`

**[ Initialization (초기화) ]**
• 변수값 초기화 필요
• 멤버 변수 선언할 때 동시에 : class default 지정

```java
double weight = 430; // soccer ball’s
int x; // = 0 by default (숫자형)
```


```java
class Box {
    double width; // 멤버 변수, (0 초기화)
    double height;
    double depth;
    default size
    Box() {
        width = height = depth = 10;
    }
    Box(int x) { this(x, x, x); }   //this: 나의 참조변수 or 나의 생성자 호출(아래 box 호출-파라미터의 수를 맞춰서)
    Box(double w, height h, depth d) {
        width = w; height = h; depth = d;
    }
}

// 다른 클래스
Box a = new Box();
Box b = new Box(10);
Box c = new Box(10, 20, 30);
```

```java
public class Book {
  String title;
  String author;

  //생성자 중복
  public Book(String t) { // 생성자 1
    title = t; author = "작자미상"; // 변수 초기화
  }

  public Book(String t, String a) { // 생성자 2
    title = t; author = a; // 변수 초기화
  }

  public static void main(String [] args) {
    Book littlePrince = new Book("어린왕자", "생텍쥐페리");// --> 생성자 2 호출
    Book loveStory = new Book("춘향전");            // --> 생성자 1 호출
    System.out.println (littlePrince.title + " " + littlePrince.author);
    System.out.println (loveStory.title + " " + loveStory.author);
  }
}
```



- 생성자 오버로딩
- 생성자 예제 (Box, Book 클래스 등)
- 기본 생성자(Default constructor)의 의미

<br>
<br>
<br>

# 접근 제어자 & 예약어
**[ `public`, `private`, `protected` 접근 범위 ]**
– controls the visibility(가시성) of variables
• open to or hidden from – outside/other objects
– “information hiding(정보은닉)” ¬ private variables

**[ `this` 키워드 (자기 참조) ]**
– this. : 명시적 self-reference (자기 참조, 자기 지칭)
anywhere : this.name
inside its method/생성자
– this(…) : only called first inside a constructor
calls another constructor

```java
public class Balloon {
	private int diameter;
	protected int x, y; // accessible from subclasses
	public boolean bouncing;
	
	public Balloon(int d, int x, int y) {
		diameter = d;
		this.x = x; // 변수 이름이 같을 때 구분하기 위해
		this.y = y;
		this.changeSize(1); // “this.” 없어도 된다
	}
	public void changeSize(int deltaR) {
		diameter += deltaR;
	}
}

class SomeClass { …
	Balloon b = new Balloon(10, 0,0);
	b.diameter = 15; // ( X - error )
	b.changeSize(5); // (o)
}

```

```java
public class Book {
	String title;
	String author;
	public Book(String t) { // 생성자 1
		this(t, "작자미상"); // 다른 중복 생성자 호출
	}

	public Book(String t, String a) { // 생성자 2
		title = t; author = a; // 변수 초기화
	}
	public static void main(String [] args) {
	
		Book littlePrince = new Book("어린왕자", "생텍쥐페리");
		Book loveStory = new Book("춘향전");
		System.out.println (littlePrince.title + " " + littlePrince.author);
		System.out.println (loveStory.title + " " + loveStory.author);
	}
}

```

**[ `super` 키워드 (상위 클래스 참조) ]**
– super.
- : parent class reference (상위 클래스 객체 참조)
– super(…) : only called first inside a constructor
inside its constructor super.job
(첫 문장) - 5장에서!

<br>
<br>
<br>

# 메서드 오버로딩
**[ 메서드 오버로딩 개념 ]**
Two or more methods of
– the same name
– different number/type of input arguments, but
– the same return value type
• a way of realizing polymorphism (다형성, 한 객체 여러 모습/동작)

```java
//Animal.java
public class Animal {
	String name, 색;
	public void set (String name, String color) {
		this.name = name; 색 = color;
	}
	public void setName (String name) { …}
	public void set (String sack) { … }
}

Animal a = new Animal();
a.set(“Micky”, “black”);
a.set(“gray”);
```

- 생성자 오버로딩과의 차이

```java
Box (double w, double h, double d) {…}
Box () {…}
Box (double lne) {…}

Box a = new Box();
Box b = new Box(2.0, 3, 4);
Box c = new Box(10);
```

<br>
<br>
<br>

# 인자 전달 방식
Transmitting actual arguments to formal
parameters of a method
a.set(RED) void set(int sack){…}

**[ Call-by-Value ]**
> 값에 의한 호출
• 실인자의 값을 (복사하여) 전달한다/넘긴다
• 복귀했을 때 실인자 값은 변치 않는다
• built-in type data : primitive type

```java
public class CBV { public static void main(String a[]) { Value obj = new Value();
	int a = 10;
	System.out.println(a); // -> output: 10
	obj.treat(a); 			// a = 실(제)인자
	System.out.println(a); // -> output: 10
	}
}
class Value {
	void treat(int n) { // a copy is transferred
		n++; // n = 형식인자, n은 그냥 버린다
	}
}
```


**[ Call-by-Reference ]**
> 참조에 의한 호출
• 참조reference를 전달한다
• 실인자의 내용이 변한다/변할 수 있다

```java
public class CBR{
	public static void main(String a[]) { 
		Ref obj = new Ref(10); 
		System.out.println(obj.x); // -> output: 10
		obj.treat(obj); // 참조를 전달
		System.out.println(obj.x); // -> output: 11
	}
}
class Ref {
	int x;
	Ref(int x) { this.x = x; } 
	void treat(Ref that) { // a copy of reference ¹ 	object
		that.x ++;
	}
}
```

<br>
<br>
<br>

# 정적 멤버 (Static)
## 클래스 변수/메서드 (`static`)
**[ static members ]**
> 특정 객체와 무관한, 일종의 전역 변/함수
• variables/methods common to all objects of a class
“class variables”, “class methods”

|구분|내용|
|---|---|
|static variables|(사본 없음->같은 타입의 모든 객체가 공유)<br>• global variables, not duplicated/copied<br>• object instances share them|
|static methods|(객체 없이도, 클래스 이름으로 호출가능)<br>used without object instantiation<br>1) can invoke only other static methods<b>2) can
access only static variables<br>3) cannot use this/super|


```java
double y = Math.sqrt(2);	//-> y = 1.414…
String z = Integer.toString(255);	//-> z = “255”
System.out.println("abs value is = " + Math.abs(-5));

final 의미, extends 의미
public final class Math extends Object {
static double E = 2.71828…;
static double PI = 3.1415…;
static double abs(double a) { … }
static double random(double a) { … }
…
}
```


```java
public class Calcs {
	public static int magic = 20;
	public static int sum (int x, int y) {
		return x + y;
	}
	public int getMagic() { 
		return magic; 
	}
}

int c = Calcs.sum(5, Calcs.magic);
int d = Calcs.getMagic(); // error -> ?
```



- 왜 static이 필요한가?

<br>
<br>
<br>

# 중첩 클래스 (Nested Class)

## 정의
> class 안에 class를 정의한 것
• nested class는 외부 class 안에서[만] 존재 유효
• 외부 class의 모든 변수를 access한다
– 외부 class는 nested class의 멤버를 access하지 못함

## 중첩 클래스 사용이유
 Compelling reasons for using :
(1) It’s a way of logically grouping classes that are only
used in one place
• Logical if useful only to one other class – kinda “helper
classes” – and makes it more streamlined
(2) It increases encapsulation
• Hidden from the outside world
(3) It can lead to more readable and maintainable code
 put related small classes close to where they are neededㅍ

## 두 가지 유형– 총 4 가지가 있다:
1. static nested class/interface = “top-level
class/interface”
: 내부에 있긴 있는데, 밖에 있어도 상관없는 클래스 > static을 쓴다

2. non-static nested class = “inner class” - 3가지:
• includes member class, local class, anonymous class
: 멤버변수, 생성자, 멤버함수, 클래스
: 함수안에 클래스가 들어감(메소드 안에)
: 

```java
//(1) Static nested class
class OuterClass {
...
	static class StaticNestedClass {	//정적 중첩 클래스
	...
	}
	class InnerClass {	//멤버 클래스
	...
	}
	void anyMethod(...) {
	...
	}
}

//Usage:
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
```

```java
//(2) member class – a member
class OuterA {
	int outX = 10;
	void test() {
		InnerB in = new InnerB();
		in.innerDisplay();
	}
	class InnerB { // 멤버 클래스
		int inX = 11;
		void innerDisplay() {
		System.out.println(“InnerB: outX = “ + outX);
	}
}

//Cf
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
```

```java

```

```java

```
