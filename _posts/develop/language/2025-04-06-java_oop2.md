---
title: "[자바 객체지향] 상속"
excerpt: " 클래스와 객체, 생성자, 오버로딩"
categories:
  - language
tags: [자바객체지향, Java]
toc: true
author_profile: true 
sidebar:
   nav: "docs"
---


# 상속(Ingeritance)
## 상속의 개념

**[ 상속이란 ]**
> 


**[ 상속을 사용하는 이유 ]**
• 소프트웨어를 재사용(reuse)하는 방법<br>
• general class definition -> specialized class를 간단하고 효과적으로 정의 `참고`<br>

`참고` 클래스의 정의해 필요한 정보만 추가, 기존내용 변경을 통해


## 상속과 객체 간 관계

**[ Inter-class Relationships ]**<br>
**IsA relation(상속 관계)**<br>
하위 타입(subtype)을 정의함
주로 공통적인 속성과 기능을 재사용하고자 할 때 사용
A가 B의 일종이다 라는 의미: "자동차는 탈것(Vehicle)의 일종이다" → Automobile extends Vehicle
Java에서 extends 키워드를 사용함

```java
class Automobile extends Vehicle { ... }
```

```java
// 상속관계(isA)를 예로 설명한 도형 클래스 계층도

                 Shape
               /       \
         2DShape       3DShape
         /   |   \         |   \
     Oval Rectangle Triangle  Sphere Cube
      |       |       |
    Circle  Square  EquilateralTriangle
                         \
                      IsoscelesTriangle

       Parallelogram
              |
           Diamond

```


**HasA relation(포함 관계)**<br>
복합 객체(composite)를 정의함
객체를 하위 구성요소로 포함함
코드에서는 클래스 내부에 다른 객체 타입을 필드로 선언함으로써 표현
이런 관계는 클래스 내부에 부품처럼 다른 객체를 조립해서 쓰는 구조
A가 B를 갖고 있다는 의미: "자동차는 바퀴를 갖고 있다" → 자동차 클래스 안에 Wheel 객체를 포함

```java
class Automobile ... {
    Color shade;
    Wheel wheels[4];
    ...
}
```

일반화와 특수화

**[ Object 클래스와 메서드들]**<br>
**정의**
> `Object` 클래스
클래스 계층 구조의 최상위 클래스로, 모든 클래스는 Object의 메소드를 자동으로 상속 
클래스 계층의 뿌리 (※ `객체`가 아닌 `Object`라는 이름)
java.lang 패키지에 정의되어 있음
모든 클래스의 슈퍼클래스 (기본 명세 제공)

```java
clone()
equals(Object)          // 두 객체가 같은지 비교
finalize()  
getClass()
hashCode()              // 객체의 해시값 반환 (HashMap, HashSet에 중요)
notify()                // 멀티스레드 간의 대기/알림 기능
notifyAll()
toString()              // 객체를 출력할 때 문자열로 표현
wait([long][, nanosec]) // 멀티스레드 간의 대기/알림 기능
```

**참고**
java SE document를 구글에 검색해서 → Oracle의 공식 Java API 문서에 들어감

java.base 모듈 → java.lang 패키지 → Object 클래스를 확인

클래스 계층과 함께 Object 클래스의 메소드 요약(설명 포함)을 볼 수 있음


**[ 요약 ]**
• 상위 클래스의 변수/메소드를 상속-> 재활용 한다<br>
`(e.g., student: getName() == super.getName())`<br>
• 모든 (학생/교수/직원)을 한 가지의 종류(Person)으로 다
룰/저장할 수 있다: 다형성(polymorphism)<br>
• 상위 클래스의 생성자를 호출/실행할 수 있다<br>
`(e.g., super(…));`<br>
• 상위 클래스의 메쏘드를 overriding 하기도 한다<br>
`(e.g., student: info() == Student.info() =! Person.info())`<br>
• 상위 클래스의 overridden 메쏘드를 직접 호출할 수 있다<br>`(e.g., super.info())`


<br>
<br>
<br>

# 메소드 오버라이딩
## overriding, 대체
**[ 정의 ]**
> 클래스 상속 관계에서 반환자료형, 메쏘드 이름, 인자형과 인자수가 같을 때 파생 클래스의 메쏘드를 사용하는 것 

**[ 오버로딩 vs 오버라이딩 ]**<br>
overriding(대체) <-> overloading(중복, 한 클래스 내에서)

**[ 오버라이딩의 내부 실행 과정 ]**<br>

```java
student.getName()
```

메쏘드 호출 > 현클래스에서 메쏘드 탐색 > 없으면 직상위 클래스 탐색 > 없으면 차상위 > 결국 못찾으면 오류(compile error)


**[ 예시 ]**<br>
> People - Student - MaleStudent hierarchy:<br>
• People → writeOutput() 출력: "a"<br>
• Student2 → writeOutput() 출력: "b"<br>
• MaleStudent → writeOutput() 출력: "c"

`참고` 오버라이딩된 메서드는 가장 하위 클래스의 것을 우선 실행함

```java
People → Student2 → MaleStudent
```

|클래스|멤버변수|접근제어자|자식클래스 접근|
|:---:|:---:|:---:|:---:|
|People|penName|private|❌|
|People|name|protected|	⭕|
|Student2|studentYear|private|❌|
|MaleStudent|doArmy|private|⭕|

```java
class People {
    private String penName;

    People() { ... }
    People(String name) { ... }

    public String changeName(String name) {
        this.name = name;
    }

    public void writeOutput() {
        System.out.println("내 이름: " + name);
    }

    protected String name;
}
// name은 protected로 선언되어, 하위 클래스(Student2, MaleStudent)에서 사용 가능
// penName은 private이라 자식 클래스에서 접근 불가
```

```java
class Student2 extends People {
    Student2() { ... }
    Student2(String name, ...) { ... }

    public void reset(String name, int year) {
        changeName(name);
        studentYear = year;
    }

    public void writeOutput() {
        System.out.println("제 이름: " + name);
    }

    private int studentYear;
}
// changeName()을 호출해 People 클래스의 name 필드를 설정
// studentYear는 private이므로 MaleStudent에서 직접 접근 불가
```

```java
class MaleStudent extends Student2 {
    MaleStudent() { ... }
    MaleStudent(String name, ...) { ... }

    public void writeOutput() {
        System.out.println("제 이름: " + name);
        System.out.println("학년: " + studentYear);
        System.out.println("병역필: " + doArmy);
    }

    private boolean doArmy; // dutyOfArmy
}
// name은 protected → 접근 가능
// studentYear는 private → 직접 접근 불가 (오류 발생)
// doArmy는 자신의 클래스에 선언된 private → 내부에서는 접근 가능
```


<br>
<br>
<br>

# 다형성 (feat. overriding)

> 문제: 다형성을 만드는 두가지 방법!

<br>
<br>
<br>

# 캐스팅과 기타 문법(static, fianl)

**[ Casting ]**

Promotion (승급)
• subclass 객체를 superclass 객체로 치환
• Animal animal = aDog;
Demotion (강등)
• superclass 객체를 subclass 객체로 치환
• casting: 강제적 형변환이 필요하다 `Dog bDog = (Dog) animal;`
• 컴파일러 타당/통과: animal이 위처럼 원래 Dog 객체가 아니었다면 실행할 때 오류가 발생

**[ instanceof 연산자 ]**
> instanceof 연산자
 참조(변수)가 가리키는 객체의 유형(class) 식별
형식: 객체_
참조 instanceof 클래스_이름 -> 연산의 결과 : true 또는 false
– 예.
new Professor() 객체는 Professor 타입이면서, 동시에
Employee 타입이기도 하고, Person 타입이기도 함
Person p = new Professor();
If (p instanceof Person) If (p instanceof Student) If (p instanceof Employee) If (p instanceof Professor) // true
// true
// true
// false. Student를 상속받지 않았다
If ("java" instanceof String) // true
If (3 instanceof int) // 문법 오류. instanceof는 참조 자료형에만 사용


**[ final and static ]**

• non-overridable [class] variable
– static final float CmPerInch = 2.54;


`class A: final int a`
`class B: float a` ㅌㅌ
• Essentially constants
– public final static float C =2.9989E+10f;
– public final static int SCREEN_WIDTH = 640;
